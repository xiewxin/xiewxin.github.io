<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>辅助函数 | xiewixn blog</title>
<meta name="description" content="闲庭若步">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="http://xiewxin.github.io//favicon.ico?v=1596389143406">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="http://xiewxin.github.io//styles/main.css">


<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="http://xiewxin.github.io/">xiewixn blog</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                归档
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                标签
              </a>
            
          </li>
        
          <li>
            
              <a href="/post/about" class="menu">
                关于
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>辅助函数</h1>
            <p class="article-meta">
              2020-06-07
              
            </p>
            
            <div class="post-content">
              <h1 id="辅助函数">辅助函数</h1>
<h2 id="可用方法">可用方法</h2>
<h3 id="数组对象">数组&amp;对象</h3>
<p>Arr::add<br>
Arr::collapse<br>
Arr::crossJoin<br>
Arr::divide<br>
Arr::dot<br>
Arr::except<br>
Arr::first<br>
Arr::flatten<br>
Arr::forget<br>
Arr::get<br>
Arr::has<br>
Arr::isAssoc<br>
Arr::last<br>
Arr::only<br>
Arr::pluck<br>
Arr::prepend<br>
Arr::pull<br>
Arr::random<br>
Arr::query<br>
Arr::set<br>
Arr::shuffle<br>
Arr::sort<br>
Arr::sortRecursive<br>
Arr::where<br>
Arr::wrap<br>
data_fill<br>
data_get<br>
data_set<br>
head<br>
last</p>
<h3 id="路徑">路徑</h3>
<p>app_path<br>
base_path<br>
config_path<br>
database_path<br>
mix<br>
public_path</p>
<p>resource_path</p>
<p>storage_path</p>
<h3 id="字符串">字符串</h3>
<p>__</p>
<p>class_basename<br>
e<br>
preg_replace_array<br>
Str::after<br>
Str::afterLast<br>
Str::before<br>
Str::beforeLast<br>
Str::camel<br>
Str::contains<br>
Str::containsAll<br>
Str::endsWith<br>
Str::finish<br>
Str::is<br>
Str::isUuid<br>
Str::kebab<br>
Str::limit<br>
Str::orderedUuid<br>
Str::plural<br>
Str::random<br>
Str::replaceArray<br>
Str::replaceFirst<br>
Str::replaceLast<br>
Str::singular</p>
<p>Str::slug<br>
Str::snake<br>
Str::start<br>
Str::startsWith<br>
Str::studly<br>
Str::title<br>
Str::ucfirst<br>
Str::uuid<br>
Str::words<br>
trans<br>
trans_choice</p>
<h2 id="方法列表">方法列表</h2>
<h3 id="数组对象-2">数组&amp;对象</h3>
<h4 id="arradd-collection-method-first-collection-method"><code>Arr::add()</code> {#collection-method .first-collection-method}</h4>
<p>如果给定的键在数组中不存在或数组被设置为 <code>null</code> ，那么 <code>Arr::add</code> 函数将会把给定的键值对添加到数组中：</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::add(['name' =&gt; 'Desk'], 'price', 100);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]

$array = Arr::add(['name' =&gt; 'Desk', 'price' =&gt; null], 'price', 100);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<h4 id="arrcollapse-collection-method"><code>Arr::collapse()</code> {#collection-method}</h4>
<p><code>Arr::collapse</code> 函数将多个数组合并为一个数组:</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);

// [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<h4 id="arrcrossjoin-collection-method">Arr::crossJoin() {#collection-method}</h4>
<p><code>Arr :: crossJoin</code> 函数交叉连接给定的数组，返回具有所有可能排列的笛卡尔乘积：</p>
<pre><code>use Illuminate\Support\Arr;

$matrix = Arr::crossJoin([1, 2], ['a', 'b']);

/*
    [
        [1, 'a'],
        [1, 'b'],
        [2, 'a'],
        [2, 'b'],
    ]
*/

$matrix = Arr::crossJoin([1, 2], ['a', 'b'], ['I', 'II']);

/*
    [
        [1, 'a', 'I'],
        [1, 'a', 'II'],
        [1, 'b', 'I'],
        [1, 'b', 'II'],
        [2, 'a', 'I'],
        [2, 'a', 'II'],
        [2, 'b', 'I'],
        [2, 'b', 'II'],
    ]
*/
</code></pre>
<h4 id="arrdivide-collection-method"><code>Arr::divide()</code> {#collection-method}</h4>
<p><code>Arr::divide</code> 函数返回一个二维数组，一个值包含原始数组的键，另一个值包含原始数组的值</p>
<pre><code>use Illuminate\Support\Arr;

[$keys, $values] = Arr::divide(['name' =&gt; 'Desk']);

// $keys: ['name']

// $values: ['Desk']
</code></pre>
<h4 id="arrdot-collection-method">Arr::dot() {#collection-method}</h4>
<p><code>Arr::dot</code> 函数将多维数组中所有的键平铺到一维数组中，新数组使用「.」符号表示层级包含关系：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$flattened = Arr::dot($array);

// ['products.desk.price' =&gt; 100]
</code></pre>
<h4 id="arrexcept-collection-method">Arr::except() {#collection-method}</h4>
<p><code>Arr::except</code> 函数从数组中删除指定的键值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100];

$filtered = Arr::except($array, ['price']);

// ['name' =&gt; 'Desk']
</code></pre>
<h4 id="arrfirst-collection-method">Arr::first() {#collection-method}</h4>
<p><code>Arr::first</code> 函数返回数组中通过真值测试的第一个元素：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, 200, 300];

$first = Arr::first($array, function ($value, $key) {
    return $value &gt;= 150;
});

// 200
</code></pre>
<p>将默认值作为第三个参数传递给该方法， 如果数组中没有值通过真值测试，则返回默认值：</p>
<pre><code>use Illuminate\Support\Arr;

$first = Arr::first($array, $callback, $default);
</code></pre>
<h4 id="arrflatten-collection-method">Arr::flatten() {#collection-method}</h4>
<p><code>Arr::flatten</code> 函数将多维数组中数组的值取出平铺为一维数组：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Joe', 'languages' =&gt; ['PHP', 'Ruby']];

$flattened = Arr::flatten($array);

// ['Joe', 'PHP', 'Ruby']
</code></pre>
<h4 id="arrforget-collection-method">Arr::forget() {#collection-method}</h4>
<p><code>Arr::forget</code> 函数使用「.」符号从深度嵌套的数组中删除给定的键值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

Arr::forget($array, 'products.desk');

// ['products' =&gt; []]
</code></pre>
<h4 id="arrget-collection-method">Arr::get() {#collection-method}</h4>
<p><code>Arr::get</code> 函数使用「.」符号从深度嵌套的数组中根据指定键检索值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$price = Arr::get($array, 'products.desk.price');

// 100
</code></pre>
<p><code>Arr::get</code> 函数也接受一个默认值，如果没有找到特定的键，将返回默认值：</p>
<pre><code>use Illuminate\Support\Arr;

$discount = Arr::get($array, 'products.desk.discount', 0);

// 0
</code></pre>
<h4 id="arrhas-collection-method">Arr::has() {#collection-method}</h4>
<p><code>Arr::has</code> 函数使用「.」符号查找数组中是否存在指定的一个或多个键：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]];

$contains = Arr::has($array, 'product.name');

// true

$contains = Arr::has($array, ['product.price', 'product.discount']);

// false
</code></pre>
<h4 id="arrisassoc-collection-method">Arr::isAssoc() {#collection-method}</h4>
<p>如果给定数组是关联数组，则 <code>Arr::isAssoc</code> 函数返回 <code>true</code> 。如果数组没有以零开头的连续数字键，则将其视为 “关联”。</p>
<pre><code>use Illuminate\Support\Arr;

$isAssoc = Arr::isAssoc(['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]]);

// true

$isAssoc = Arr::isAssoc([1, 2, 3]);

// false
</code></pre>
<h4 id="arrlast-collection-method">Arr::last() {#collection-method}</h4>
<p><code>Arr::last</code> 函数返回数组中满足指定条件的最后一个元素：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, 200, 300, 110];

$last = Arr::last($array, function ($value, $key) {
    return $value &gt;= 150;
});

// 300
</code></pre>
<p>将默认值作为第三个参数传递给该方法，如果没有值通过真值测试，则返回该默认值：</p>
<pre><code>use Illuminate\Support\Arr;

$last = Arr::last($array, $callback, $default);
</code></pre>
<h4 id="arronly-collection-method">Arr::only() {#collection-method}</h4>
<p><code>Arr::only</code> 函数只返回给定数组中指定的键值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100, 'orders' =&gt; 10];

$slice = Arr::only($array, ['name', 'price']);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<h4 id="arrpluck-collection-method">Arr::pluck() {#collection-method}</h4>
<p><code>Arr::pluck</code> 函数从数组中检索给定键的所有值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['developer' =&gt; ['id' =&gt; 1, 'name' =&gt; 'Taylor']],
    ['developer' =&gt; ['id' =&gt; 2, 'name' =&gt; 'Abigail']],
];

$names = Arr::pluck($array, 'developer.name');

// ['Taylor', 'Abigail']
</code></pre>
<p>你也可以指定获取的结果的键：</p>
<pre><code>use Illuminate\Support\Arr;

$names = Arr::pluck($array, 'developer.name', 'developer.id');

// [1 =&gt; 'Taylor', 2 =&gt; 'Abigail']
</code></pre>
<h4 id="arrprepend-collection-method">Arr::prepend() {#collection-method}</h4>
<p><code>Arr::prepend</code> 函数将一个值插入到数组的开始位置：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['one', 'two', 'three', 'four'];

$array = Arr::prepend($array, 'zero');

// ['zero', 'one', 'two', 'three', 'four']
</code></pre>
<p>如果需要，你可以指定你插入值的键：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['price' =&gt; 100];

$array = Arr::prepend($array, 'Desk', 'name');

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<h4 id="arrpull-collection-method">Arr::pull() {#collection-method}</h4>
<p><code>Arr::pull</code> 函数从数组中返回指定键的值并删除此键／值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100];

$name = Arr::pull($array, 'name');

// $name: Desk

// $array: ['price' =&gt; 100]
</code></pre>
<p>默认值可以作为第三个参数传递给该方法，如果键不存在，则返回该值：</p>
<pre><code>use Illuminate\Support\Arr;

$value = Arr::pull($array, $key, $default);
</code></pre>
<h4 id="arrrandom-collection-method">Arr::random() {#collection-method}</h4>
<p><code>Arr::random</code> 函数从数组中随机返回一个值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [1, 2, 3, 4, 5];

$random = Arr::random($array);

// 4 - (retrieved randomly)
</code></pre>
<p>你也可以将返回值的数量作为可选的第二个参数传递给该方法，请注意，提供这个参数会返回一个数组，即使是你只需要一项：</p>
<pre><code>use Illuminate\Support\Arr;

$items = Arr::random($array, 2);

// [2, 5] - (retrieved randomly)
</code></pre>
<h4 id="arrquery-collection-method">Arr::query() {#collection-method}</h4>
<p><code>Arr::query</code> 函数将数组转换为查询字符串：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Taylor', 'order' =&gt; ['column' =&gt; 'created_at', 'direction' =&gt; 'desc']];

Arr::query($array);

// name=Taylor&amp;order[column]=created_at&amp;order[direction]=desc
</code></pre>
<h4 id="arrset-collection-method">Arr::set() {#collection-method}</h4>
<p><code>Arr::set</code> 函数使用「.」符号在多维数组中设置指定键的值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

Arr::set($array, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 200]]]
</code></pre>
<h4 id="arrshuffle-collection-method">Arr::shuffle() {#collection-method}</h4>
<p><code>Arr::shuffle</code> 函数将数组中值进行随机排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::shuffle([1, 2, 3, 4, 5]);

// [3, 2, 5, 1, 4] - (generated randomly)
</code></pre>
<h4 id="arrsort-collection-method">Arr::sort() {#collection-method}</h4>
<p><code>Arr::sort</code> 函数根据数组的值对数组进行排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['Desk', 'Table', 'Chair'];

$sorted = Arr::sort($array);

// ['Chair', 'Desk', 'Table']
</code></pre>
<p>你也可以根据给定闭包返回的结果对数组进行排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['name' =&gt; 'Desk'],
    ['name' =&gt; 'Table'],
    ['name' =&gt; 'Chair'],
];

$sorted = array_values(Arr::sort($array, function ($value) {
    return $value['name'];
}));

/*
    [
        ['name' =&gt; 'Chair'],
        ['name' =&gt; 'Desk'],
        ['name' =&gt; 'Table'],
    ]
*/
</code></pre>
<h4 id="arrsortrecursive-collection-method">Arr::sortRecursive() {#collection-method}</h4>
<p><code>Arr::sortRecursive</code> 函数使用 <code>sort</code> 函数对数值子数组进行递归排序，使用 <code>ksort</code> 函数对关联子数组进行递归排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['Roman', 'Taylor', 'Li'],
    ['PHP', 'Ruby', 'JavaScript'],
    ['one' =&gt; 1, 'two' =&gt; 2, 'three' =&gt; 3],
];

$sorted = Arr::sortRecursive($array);

/*
    [
        ['JavaScript', 'PHP', 'Ruby'],
        ['one' =&gt; 1, 'three' =&gt; 3, 'two' =&gt; 2],
        ['Li', 'Roman', 'Taylor'],
    ]
*/
</code></pre>
<h4 id="arrwhere-collection-method">Arr::where() {#collection-method}</h4>
<p><code>Arr::where</code> 函数使用给定闭包返回的结果过滤数组：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, '200', 300, '400', 500];

$filtered = Arr::where($array, function ($value, $key) {
    return is_string($value);
});

// [1 =&gt; '200', 3 =&gt; '400']
</code></pre>
<h4 id="arrwrap-collection-method">Arr::wrap() {#collection-method}</h4>
<p><code>Arr::wrap</code> 方法可以将给定值转换为一个数组。如果给定值已经是一个数组，将不会进行转换：</p>
<pre><code>use Illuminate\Support\Arr;

$string = 'Laravel';

$array = Arr::wrap($string);

// ['Laravel']
</code></pre>
<p>如果给定值是 <code>null</code> ，将返回一个空数组：</p>
<pre><code>use Illuminate\Support\Arr;

$nothing = null;

$array = Arr::wrap($nothing);

// []
</code></pre>
<h4 id="data_fill-collection-method">data_fill() {#collection-method}</h4>
<p><code>data_fill</code> 函数以 . 形式给嵌套数组或对象中设置缺省值：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_fill($data, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]]

data_fill($data, 'products.desk.discount', 10);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100, 'discount' =&gt; 10]]]
</code></pre>
<p>这个函数也可以接收一个 <code>*</code> 作为通配符，并对相应位置进行填充：</p>
<pre><code>$data = [
    'products' =&gt; [
        ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
        ['name' =&gt; 'Desk 2'],
    ],
];

data_fill($data, 'products.*.price', 200);

/*
    [
        'products' =&gt; [
            ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
            ['name' =&gt; 'Desk 2', 'price' =&gt; 200],
        ],
    ]
*/
</code></pre>
<h4 id="data_get-collection-method">data_get() {#collection-method}</h4>
<p><code>data_get</code> 函数可使用 . 形式获得嵌套函数或者对象中的值：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$price = data_get($data, 'products.desk.price');

// 100
</code></pre>
<p>当找不到指定键名时，<code>data_get</code> 函数也支持返回一个默认值：</p>
<pre><code>$discount = data_get($data, 'products.desk.discount', 0);

// 0
</code></pre>
<p>这个函数也可以接受一个 <code>*</code> 作为通配符，以匹配数组或对象中任意键名：</p>
<pre><code>$data = [
    'product-one' =&gt; ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
    'product-two' =&gt; ['name' =&gt; 'Desk 2', 'price' =&gt; 150],
];

data_get($data, '*.name');

// ['Desk 1', 'Desk 2'];
</code></pre>
<h4 id="data_set-collection-method">data_set() {#collection-method}</h4>
<p><code>data_set</code> 函数可以用 . 形式给嵌套函数或对象赋值：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_set($data, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 200]]]
</code></pre>
<p>这个函数也支持使用 <code>*</code> 作为通配符给相应键名赋值：</p>
<pre><code>$data = [
    'products' =&gt; [
        ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
        ['name' =&gt; 'Desk 2', 'price' =&gt; 150],
    ],
];

data_set($data, 'products.*.price', 200);

/*
    [
        'products' =&gt; [
            ['name' =&gt; 'Desk 1', 'price' =&gt; 200],
            ['name' =&gt; 'Desk 2', 'price' =&gt; 200],
        ],
    ]
*/
</code></pre>
<p>通常情况下，已存在的值将会被覆盖。如果只是希望设置一个目前不存在的值，你可以增加一个 <code>false</code> 作为函数的第四个参数：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_set($data, 'products.desk.price', 200, false);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]]
</code></pre>
<h4 id="head-collection-method">head() {#collection-method}</h4>
<p><code>head</code> 函数将返回数组中的第一个值：</p>
<pre><code>$array = [100, 200, 300];

$first = head($array);

// 100
</code></pre>
<h4 id="last-collection-method">last() {#collection-method}</h4>
<p><code>last</code> 返回给定数组的最后一个元素：</p>
<pre><code>$array = [100, 200, 300];

$last = last($array);

// 300
</code></pre>
<h3 id="路徑-2">路徑</h3>
<h4 id="app_path-collection-method"><code>app_path()</code> {#collection-method}</h4>
<p><code>app_path</code> 函数返回 <code>app</code> 目录的完整路径。 你也可以用 <code>app_path</code> 函数去生成应用程序目录下一个文件的完整路径：</p>
<pre><code>$path = app_path();

$path = app_path('Http/Controllers/Controller.php');
</code></pre>
<h4 id="base_path-collection-method"><code>base_path()</code> {#collection-method}</h4>
<p><code>base_path</code> 函数返回项目根目录的完整路径。 你也可以用 <code>base_path</code> 函数生成项目根目录下一个文件的完整路径：</p>
<pre><code>$path = base_path();

$path = base_path('vendor/bin');
</code></pre>
<h4 id="config_path-collection-method"><code>config_path()</code> {#collection-method}</h4>
<p><code>config_path</code> 函数返回 <code>config</code> 目录的完整路径。你也可以用 <code>config_path</code> 函数去生成应用程序配置目录下一个指定文件的完整路径：</p>
<pre><code>$path = config_path();

$path = config_path('app.php');
</code></pre>
<h4 id="database_path-collection-method"><code>database_path()</code> {#collection-method}</h4>
<p><code>database_path</code> 函数返回 <code>database</code> 目录的完整路径。 你也可以用 <code>database_path</code> 函数去生成 <code>database</code>目录下一个指定文件的完整路径：</p>
<pre><code>$path = database_path();

$path = database_path('factories/UserFactory.php');
</code></pre>
<h4 id="mix-collection-method"><code>mix()</code> {#collection-method}</h4>
<p><code>mix</code> 返回 <a href="https://learnku.com/docs/laravel/7.x/mix">版本化 MIX 文件</a> 的路径:</p>
<pre><code>$path = mix('css/app.css');
</code></pre>
<h4 id="public_path-collection-method"><code>public_path()</code> {#collection-method}</h4>
<p><code>public_path</code> 函数返回 <code>public</code> 目录的完整路径。 你也可以用 <code>public_path</code> 函数去生成 <code>public</code> 目录下一个指定文件的完整路径：</p>
<pre><code>$path = public_path();

$path = public_path('css/app.css');
</code></pre>
<h4 id="resource_path-collection-method"><code>resource_path()</code> {#collection-method}</h4>
<p><code>resource_path</code> 函数返回 <code>resources</code> 目录的完整路径。你也可以用 <code>resource_path</code> 函数去生成资源文件目录下的一个指定文件的完整路径：</p>
<pre><code>$path = resource_path();

$path = resource_path('sass/app.scss');
</code></pre>
<h4 id="storage_path"><code>storage_path()</code></h4>
<p><code>storage_path</code> 函数返回指向 “storage” 目录的绝对路径。还可以使用 <code>storage_path</code> 函数生成 <code>storage</code> 目录下给定文件的完整路径：</p>
<pre><code>$path = storage_path();

$path = storage_path('app/file.txt');
</code></pre>
<h3 id="字符串函数">字符串函数</h3>
<h4 id="__"><code>__()</code></h4>
<p><code>__</code>函数可使用 本地化文件 翻译指定的字符串或者键值：</p>
<pre><code>echo __('Welcome to our application');

echo __('messages.welcome');
</code></pre>
<p>如果指定的转换字符串或键不存在，<code>__</code> 函数将返回原来的值。即：如果 <code>messages.welcome</code> 键值不存在，则返回 <code>messages.welcome</code>。</p>
<h4 id="e"><code>e()</code></h4>
<p><code>e</code> 函数在指定字符串上运行 htmlentities 方法（double_encode 参数为 false）：</p>
<pre><code>echo e('&lt;html&gt;foo&lt;/html&gt;');

// &amp;lt;html&amp;gt;foo&amp;lt;/html&amp;gt;
</code></pre>
<h4 id="preg_replace_array"><code>preg_replace_array()</code></h4>
<p><code>preg_replace_array</code> 函数使用正则规则用给定数组替换字符串中的内容：</p>
<pre><code>$string = 'The event will take place between :start and :end';

$replaced = preg_replace_array('/:[a-z_]+/', ['8:30', '9:00'], $string);

// The event will take place between 8:30 and 9:00
</code></pre>
<h4 id="strafter"><code>Str::after()</code></h4>
<p><code>Str::after</code> 方法返回字符串中给定值之后的所有内容。如果字符串中不存在该值，则将返回整个字符串：</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::after('This is my name', 'This is');

// ' my name'
</code></pre>
<h4 id="strafterlast"><code>Str::afterLast()</code></h4>
<p><code>Str::afterLast</code> 方法返回字符串中给定值最后一次出现后的所有内容。如果字符串中不存在该值，则将返回整个字符串：</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::afterLast('App\Http\Controllers\Controller', '\\');

// 'Controller'
</code></pre>
<h4 id="strbefore-collection-method"><code>Str::before()</code> {#collection-method}</h4>
<p><code>Str::before</code> 方法返回字符串中给定值之前的所有内容：use Illuminate\Support\Str;</p>
<pre><code>$slice = Str::before('This is my name', 'my name');

// 'This is '
</code></pre>
<h4 id="strbeforelast"><code>Str::beforeLast()</code></h4>
<p><code>Str::beforeLast</code> 方法返回字符串中给定值最后出现之前的所有内容：</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::beforeLast('This is my name', 'is');

// 'This '
</code></pre>
<h4 id="strcamel"><code>Str::camel()</code></h4>
<p><code>Str::camel</code> 方法将给定字符串转换为 <code>camelCase</code>（驼峰式）：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::camel('foo_bar');

// fooBar
</code></pre>
<h4 id="strcontains-collection-method"><code>Str::contains()</code> {#collection-method}</h4>
<p><code>Str::contains</code> 方法判断给定的字符串是否包含给定的值（区分大小写）：</p>
<pre><code>use Illuminate\Support\Str;

$contains = Str::contains('This is my name', 'my');

// true
</code></pre>
<p>你也可以传递一个数组形式的值来判断给定的字符串中是否包含数组中的任意一个值：</p>
<pre><code>use Illuminate\Support\Str;

$contains = Str::contains('This is my name', ['my', 'foo']);

// true
</code></pre>
<h4 id="strcontainsall-collection-method"><code>Str::containsAll()</code> {#collection-method}</h4>
<p><code>Str::containsAll</code> 方法判断给定的字符串中是否包含给定的数组中所有的值：</p>
<pre><code>use Illuminate\Support\Str;

$containsAll = Str::containsAll('This is my name', ['my', 'name']);

// true
</code></pre>
<h4 id="strendswith-collection-method"><code>Str::endsWith()</code> {#collection-method}</h4>
<p><code>Str::endsWith</code> 方法判断给定的字符串是否以给定的值结尾：</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::endsWith('This is my name', 'name');

// true
</code></pre>
<p>你也可以传递一个数组形式的值来判断给定的字符串是否以数组中的任意一个值结尾：</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::endsWith('This is my name', ['name', 'foo']);

// true

$result = Str::endsWith('This is my name', ['this', 'foo']);

// false
</code></pre>
<h4 id="strfinish-collection-method"><code>Str::finish()</code> {#collection-method}</h4>
<p><code>Str::finish</code> 方法将给定的字符串以给定的值结尾返回（如果该字符串尚未以该值结尾）：</p>
<pre><code>use Illuminate\Support\Str;

$adjusted = Str::finish('this/string', '/');

// this/string/

$adjusted = Str::finish('this/string/', '/');

// this/string/
</code></pre>
<h4 id="stris-collection-method"><code>Str::is()</code> {#collection-method}</h4>
<p><code>Str::is</code> 方法判断给定的字符串是否匹配给定的模式，星号 <code>*</code> 可以用来表示通配符：</p>
<pre><code>use Illuminate\Support\Str;

$matches = Str::is('foo*', 'foobar');

// true

$matches = Str::is('baz*', 'foobar');

// false
</code></pre>
<h4 id="strucfirst-collection-method"><code>Str::ucfirst()</code> {#collection-method}</h4>
<p><code>Str::ucfirst</code> 方法将给定的字符串首字母大写并返回：</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::ucfirst('foo bar');

// Foo bar
</code></pre>
<h4 id="strisuuid-collection-method"><code>Str::isUuid()</code> {#collection-method}</h4>
<p><code>Str::isUuid</code> 方法用来确定给定的字符串是否为有效的 UUID：</p>
<pre><code>use Illuminate\Support\Str;

$isUuid = Str::isUuid('a0a2a2d2-0b87-4a18-83f2-2529882be2de');

// true

$isUuid = Str::isUuid('laravel');

// false
</code></pre>
<h4 id="strkebab-collection-method"><code>Str::kebab()</code> {#collection-method}</h4>
<p><code>Str::kebab</code> 方法将给定的「驼峰式」字符串转化为 kebab-case「短横式」字符串</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::kebab('fooBar');

// foo-bar
</code></pre>
<h4 id="strlimit-collection-method"><code>Str::limit()</code> {#collection-method}</h4>
<p><code>Str::limit</code> 方法按给定的长度截断给定的字符串：</p>
<pre><code>use Illuminate\Support\Str;

$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20);

// The quick brown fox...
</code></pre>
<p>你也可以传递第三个参数来改变将被追加到最后的字符串：</p>
<pre><code>use Illuminate\Support\Str;

$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20, ' (...)');

// The quick brown fox (...)
</code></pre>
<h4 id="strordereduuid-collection-method"><code>Str::orderedUuid()</code> {#collection-method}</h4>
<p><code>Str::orderedUuid</code> 方法高效生成一个可存储在索引数据库列中的「第一时间」 UUID：</p>
<pre><code>use Illuminate\Support\Str;

return (string) Str::orderedUuid();
</code></pre>
<h4 id="strplural-collection-method"><code>Str::plural()</code> {#collection-method}</h4>
<p><code>Str::plural</code> 函数将字符串转换为复数形式。该函数目前仅支持英文</p>
<pre><code>use Illuminate\Support\Str;

$plural = Str::plural('car');

// cars

$plural = Str::plural('child');

// children
</code></pre>
<p>你可以提供一个整数作为函数的第二个参数来检索字符串的单数或复数形式：</p>
<pre><code>use Illuminate\Support\Str;

$plural = Str::plural('child', 2);

// children

$plural = Str::plural('child', 1);

// child
</code></pre>
<h4 id="strrandom-collection-method"><code>Str::random()</code> {#collection-method}</h4>
<p><code>Str::random</code> 函数生成一个指定长度的随机字符串。这个函数用 PHP 的 <code>random_bytes</code> 函数：</p>
<pre><code>use Illuminate\Support\Str;

$random = Str::random(40);
</code></pre>
<h4 id="strreplacearray-collection-method"><code>Str::replaceArray()</code> {#collection-method}</h4>
<p><code>Str::replaceArray</code> 函数使用数组顺序替换字符串中的给定值：</p>
<pre><code>use Illuminate\Support\Str;

$string = 'The event will take place between ? and ?';

$replaced = Str::replaceArray('?', ['8:30', '9:00'], $string);

// 活动将在 8:30 至 9:00 之间进行
</code></pre>
<h4 id="strreplacefirst-collection-method"><code>Str::replaceFirst()</code> {#collection-method}</h4>
<p><code>Str::replaceFirst</code> 函数替换字符串中给定值的第一个匹配项：</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::replaceFirst('the', 'a', 'the quick brown fox jumps over the lazy dog');

// a quick brown fox jumps over the lazy dog
</code></pre>
<h4 id="strreplacelast-collection-method"><code>Str::replaceLast()</code> {#collection-method}</h4>
<p><code>Str::replaceLast</code> 函数替换字符串中最后一次出现的给定值：</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::replaceLast('the', 'a', 'the quick brown fox jumps over the lazy dog');

// the quick brown fox jumps over a lazy dog
</code></pre>
<h4 id="strsingular-collection-method"><code>Str::singular()</code> {#collection-method}</h4>
<p><code>Str::singular</code> 函数将字符串转换为单数形式。该函数目前仅支持英文：</p>
<pre><code>use Illuminate\Support\Str;

$singular = Str::singular('cars');

// car

$singular = Str::singular('children');

// child
</code></pre>
<h4 id="strslug-collection-method"><code>Str::slug()</code> {#collection-method}</h4>
<p><code>Str::slug</code> 函数将给定的字符串生成一个 URL 友好的 「slug」 ：</p>
<pre><code>use Illuminate\Support\Str;

$slug = Str::slug('Laravel 5 Framework', '-');

// laravel-5-framework
</code></pre>
<h4 id="strsnake-collection-method"><code>Str::snake()</code> {#collection-method}</h4>
<p><code>Str::snake</code> 函数将给定的字符串转换为 <code>snake_case</code>「蛇式」：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::snake('fooBar');

// foo_bar
</code></pre>
<h4 id="strstart-collection-method"><code>Str::start()</code> {#collection-method}</h4>
<p><code>Str::start</code> 函数将给定值添加到给定字符串的开始位置（如果字符串尚未以给定值开始）：</p>
<pre><code>use Illuminate\Support\Str;

$adjusted = Str::start('this/string', '/');

// /this/string

$adjusted = Str::start('/this/string', '/');

// /this/string
</code></pre>
<h4 id="strstartswith-collection-method"><code>Str::startsWith()</code> {#collection-method}</h4>
<p><code>Str::startsWith</code> 函数判断给定的字符串的开头是否是指定值：</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::startsWith('This is my name', 'This');

// true
</code></pre>
<h4 id="strstudly-collection-method"><code>Str::studly()</code> {#collection-method}</h4>
<p><code>Str::studly</code> 函数将给定的字符串转换为 「变种驼峰命名」：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::studly('foo_bar');

// FooBar
</code></pre>
<h4 id="strtitle-collection-method"><code>Str::title()</code> {#collection-method}</h4>
<p><code>Str::title</code> 函数将给定的字符串转换为「首字母大写」：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::title('a nice title uses the correct case');

// A Nice Title Uses The Correct Case
</code></pre>
<h4 id="struuid-collection-method"><code>Str::uuid()</code> {#collection-method}</h4>
<p><code>Str::uuid</code> 方法生成一个 UUID（版本 4）：</p>
<pre><code>use Illuminate\Support\Str;

return (string) Str::uuid();
</code></pre>
<h4 id="strwords-collection-method"><code>Str::words()</code> {#collection-method}</h4>
<p><code>Str::words</code> 函数限制字符串中的单词数：</p>
<pre><code>use Illuminate\Support\Str;

return Str::words('Perfectly balanced, as all things should be.', 3, ' &gt;&gt;&gt;');

// Perfectly balanced, as &gt;&gt;&gt;
</code></pre>
<h4 id="trans-collection-method"><code>trans()</code> {#collection-method}</h4>
<p><code>trans</code> 函数使用你的 本地文件（如：/xiewxin.github.io/docs/laravel/resources/lang/en.json） 转换给定的翻译密钥</p>
<pre><code>echo trans('messages.welcome');
</code></pre>
<p>如果指定的翻译键不存在，则 <code>trans</code> 方法会简单地返回给定的键。所以，就上面的例子而言，如果翻译键不存在， <code>trans</code> 方法会返回 <code>messages.welcome</code></p>
<h4 id="trans_choice-collection-method"><code>trans_choice()</code> {#collection-method}</h4>
<p><code>trans_choice</code> 函数根据词形变化来翻译给定的翻译键：</p>
<p>如果指定的翻译键不存在， <code>trans_choice</code> 方法会简单地返回给定的键。所以，按照上面的例子，如果翻译键不存在，<code>trans_choice</code> 方法会返回 <code>messages.notifications</code>。</p>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
        </div>
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="http://xiewxin.github.io//images/avatar.png?v=1596389143406" class="no-responsive avatar">
    <div class="text-muted">闲庭若步</div>
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="http://xiewxin.github.io/post/eloquent/">Eloquent</a>
            </li>
          
        
          
            <li>
              <a href="http://xiewxin.github.io/post/xiang-ying/">响应</a>
            </li>
          
        
          
            <li>
              <a href="http://xiewxin.github.io/post/qing-qiu-1/">請求1</a>
            </li>
          
        
          
            <li>
              <a href="http://xiewxin.github.io/post/ji-he/">集合</a>
            </li>
          
        
          
            <li>
              <a href="http://xiewxin.github.io/post/fu-zhu-han-shu/">辅助函数</a>
            </li>
          
        
          
            <li>
              <a href="http://xiewxin.github.io/post/about/">关于</a>
            </li>
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
    </div>
  </div>
  <div class="paper">
    Powered by <a href="https://github.com/xiewxin/xiewxin.github.io" target="_blank">xiewxin/xiewxin.github.io</a> | <a class="rss" href="http://xiewxin.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>




  </body>
</html>
