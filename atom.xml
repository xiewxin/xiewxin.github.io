<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://xiewxin.github.io/</id>
    <title>xiewixn blog</title>
    <updated>2020-07-18T08:52:45.244Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://xiewxin.github.io/"/>
    <link rel="self" href="http://xiewxin.github.io/atom.xml"/>
    <subtitle>闲庭若步</subtitle>
    <logo>http://xiewxin.github.io/images/avatar.png</logo>
    <icon>http://xiewxin.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, xiewixn blog</rights>
    <entry>
        <title type="html"><![CDATA[請求1]]></title>
        <id>http://xiewxin.github.io/post/qing-qiu-1/</id>
        <link href="http://xiewxin.github.io/post/qing-qiu-1/">
        </link>
        <updated>2020-07-18T08:51:19.000Z</updated>
        <content type="html"><![CDATA[<p>要通过依赖注入获取当前 HTTP 请求实例，你应该在控制器上引入 <code>Illuminate\Http\Request</code> 类。传入的请求实例将会由 服务容器 自动注入：</p>
<pre><code>&lt;?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class UserController extends Controller
{
    /**
     * Store a new user.
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        $name = $request-&gt;input('name');

        //
    }

}
</code></pre>
<h4 id="检索请求路径">检索请求路径</h4>
<p><code>path</code> 方法返回请求的路径信息。因此，如果接收到的请求目标是 <code>http://xiewxin.lv.com/home/request</code>，则 <code>path</code> 方法会返回 <code>home/request</code>：</p>
<pre><code>// 1. path 方法返回请求的路径信息。因此，如果接收到的请求
// 目标是 http://xiewxin.lv.com/home/request，
// 则 path 方法会返回 home/request
$res['path'] = $request-&gt;path();
</code></pre>
<p><code>is</code> 方法验证请求的路径是否与给定的模式匹配。使用此方法时，可以将 <code>*</code> 字符作为通配符：</p>
<pre><code>if ($request-&gt;is('admin/*')) {
    //
}
</code></pre>
<h4 id="获取请求-url">获取请求 URL</h4>
<p>要获取完整的请求 URL，你可以使用 <code>url</code> 或 <code>fullUrl</code> 方法。 <code>url</code> 方法返回不带查询条件的 URL，而 <code>fullUrl</code> 方法的返回包含查询条件字符串。</p>
<pre><code>// 没有包含查询条件字符串
$url = $request-&gt;url();

// 包含查询条件字符串
$url = $request-&gt;fullUrl();
</code></pre>
<h4 id="获取请求方法">获取请求方法</h4>
<p><code>method</code> 方法将会返回请求的 HTTP 动词。 你也可以使用 <code>isMethod</code> 方法去验证 HTTP 动词与所给定的字符串是否匹配</p>
<pre><code>$method = $request-&gt;method();

if ($request-&gt;isMethod('post')) {
    //
}
</code></pre>
<h3 id="psr-7-请求">PSR-7 请求</h3>
<p>PSR-7 标准指定了包括请求与响应在内的 HTTP 的消息接口。如果你想要获取 PSR-7 请求实例而不是 Laravel 请求， 那么你首先需要安装几个库。Laravel 使用 <em>Symfony HTTP Message Bridge</em> 组件将典型的 Laravel 请求和响应转换为 PSR-7 的兼容实现：</p>
<pre><code>composer require symfony/psr-http-message-bridge
composer require nyholm/psr7
</code></pre>
<p>安装这些库后，可以通过路由闭包和控制器方法的请求接口类型提示来获取 PSR-7 请求：</p>
<pre><code>use Psr\Http\Message\ServerRequestInterface;

Route::get('/', function (ServerRequestInterface $request) {
    //
});
</code></pre>
<h2 id="输入过滤-规范化">输入过滤 &amp; 规范化</h2>
<p>默认情况下，Laravel 应用程序的全局中间件堆栈中包含了 <code>TrimStrings</code> 和 <code>ConvertEmptyStringsToNull</code> 中间件。 它们被放在 <code>App\Http\Kernel</code> 类的栈列表中。这些中间件将自动过滤掉请求中的字符串字段，并将空字符串字段转换为 <code>null</code>。 这样一来，你将不用担心路由和控制器的约束规范问题。</p>
<p>如果你想禁用这些行为， 你可以在应用程序中 <code>App\Http\Kernel</code> 类的 <code>$middleware</code> 属性中移除这两个中间件。</p>
<h2 id="获取输入">获取输入</h2>
<p>当处理包含数组的表单时，可以使用 「.」 运算符来访问数组的数据：</p>
<pre><code>$name = $request-&gt;input('products.0.name');

$names = $request-&gt;input('products.*.name');
</code></pre>
<h4 id="从查询字符串获取输入">从查询字符串获取输入</h4>
<p><code>input</code> 方法可以从整个请求体中获取数据（包括查询字符串）, 而 <code>query</code> 方法仅仅从查询字符串中获取输入值：</p>
<pre><code>$name = $request-&gt;query('name');
</code></pre>
<h4 id="通过动态属性获取输入">通过动态属性获取输入</h4>
<p>你也可以通过 <code>Illuminate\Http\Request</code> 接口实例的动态属性访问用户的输入。例如你的一个表单中包含 <code>name</code> 字段，则可以通过下面这种方式获取：</p>
<pre><code>$name = $request-&gt;name;
</code></pre>
<h4 id="获取-json-输入">获取 JSON 输入</h4>
<p>当向应用传递 JSON 请求时，只要将请求头中的 Content-Type 设置为 <code>application/json</code> 后你便可以使用 <code>input</code>方法来获取 JSON 数据。你也可以使用「.」语法获取 JSON 数组内容：</p>
<pre><code>$name = $request-&gt;input('user.name');
</code></pre>
<h4 id="获取部分输入数据">获取部分输入数据</h4>
<p>如果需要获取输入数据的子集，你可以使用 <code>only</code> 或 <code>except</code> 方法。它们接受单个 <code>array</code> 或者动态参数列表：</p>
<pre><code>$input = $request-&gt;only(['username', 'password']);

$input = $request-&gt;only('username', 'password');

$input = $request-&gt;except(['credit_card']);

$input = $request-&gt;except('credit_card');
</code></pre>
<h4 id="判断输入值是否存在">判断输入值是否存在</h4>
<p>你可以使用 <code>has</code> 来判断当前请求中是否含有指定的值。如果请求中存在该值则 <code>has</code> 方法将会返回 <code>true</code>：</p>
<pre><code>if ($request-&gt;has('name')) {
    //
}
</code></pre>
<p>当给定一个数组时，<code>has</code> 将会判断指定的值是否全部存在：</p>
<pre><code>if ($request-&gt;has(['name', 'email'])) {
    //
}
</code></pre>
<p><code>hasAny</code> 方法将会在指定的值有一个存在的情况下返回 <code>true</code>：</p>
<pre><code>if ($request-&gt;hasAny(['name', 'email'])) {
    //
}
</code></pre>
<p>如果你想要判断一个值在请求中是否存在，并且不为空，可以使用 <code>filled</code> 方法：</p>
<pre><code>if ($request-&gt;filled('name')) {
    //
}
</code></pre>
<p>如果你想要判断一个值在请求中是否缺失，可以使用 missing 方法：</p>
<pre><code>if ($request-&gt;missing('name')) {
    //
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合]]></title>
        <id>http://xiewxin.github.io/post/ji-he/</id>
        <link href="http://xiewxin.github.io/post/ji-he/">
        </link>
        <updated>2020-06-21T15:17:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="集合">集合</h1>
<h3 id="扩展集合">扩展集合</h3>
<p>集合都是「可宏扩展」(macroable) 的，它允许你在执行时将其它方法添加到 Collection 类。例如，通过下面的代码在 <code>Collection</code> 类中添加一个 <code>toUpper</code> 方法：</p>
<pre><code>use Illuminate\Support\Collection;
use Illuminate\Support\Str;

Collection::macro('toUpper', function () {
    return $this-&gt;map(function ($value) {
        return Str::upper($value);
    });
});

$collection = collect(['first', 'second']);

$upper = $collection-&gt;toUpper();

// ['FIRST', 'SECOND']
</code></pre>
<p>通常，你应该在 服务提供者 内声明集合宏。</p>
<h2 id="可用方法">可用方法</h2>
<p>我们将讨论每个 <code>Collection</code> 类可用的方法。记住，所有这些方法都可以链式调用以流畅地操作底层数组。此外，几乎所有方法都返回一个新的 <code>Collection</code> 实例，允许你在需要时保存集合的原始副本：</p>
<p>all<br>
average<br>
avg<br>
chunk<br>
collapse<br>
collect<br>
combine<br>
concat<br>
contains<br>
containsStrict<br>
count<br>
countBy<br>
crossJoin<br>
dd<br>
diff<br>
diffAssoc<br>
diffKeys<br>
dump<br>
duplicates<br>
duplicatesStrict<br>
each<br>
eachSpread<br>
every<br>
except<br>
filter<br>
first<br>
firstWhere<br>
flatMap<br>
flatten<br>
flip<br>
forget<br>
forPage<br>
get<br>
groupBy<br>
has<br>
implode<br>
intersect<br>
intersectByKeys<br>
isEmpty<br>
isNotEmpty<br>
join<br>
keyBy<br>
keys<br>
last<br>
macro<br>
make<br>
map<br>
mapInto<br>
mapSpread<br>
mapToGroups<br>
mapWithKeys<br>
max<br>
median<br>
merge<br>
mergeRecursive<br>
min<br>
mode<br>
nth<br>
only<br>
pad<br>
partition<br>
pipe<br>
pluck<br>
pop<br>
prepend<br>
pull<br>
push<br>
put<br>
random<br>
reduce<br>
reject<br>
replace<br>
replaceRecursive<br>
reverse<br>
search<br>
shift<br>
shuffle<br>
skip<br>
slice<br>
some<br>
sort<br>
sortBy<br>
sortByDesc<br>
sortDesc<br>
sortKeys<br>
sortKeysDesc<br>
splice<br>
split<br>
sum<br>
take<br>
tap<br>
times<br>
toArray<br>
toJson<br>
transform<br>
union<br>
unique<br>
uniqueStrict<br>
unless<br>
unlessEmpty<br>
unlessNotEmpty<br>
unwrap<br>
values<br>
when<br>
whenEmpty<br>
whenNotEmpty<br>
where<br>
whereStrict<br>
whereBetween<br>
whereIn<br>
whereInStrict<br>
whereInstanceOf<br>
whereNotBetween<br>
whereNotIn<br>
whereNotInStrict<br>
whereNotNull<br>
whereNull<br>
wrap<br>
zip</p>
<h2 id="方法列表">方法列表</h2>
<h4 id="all"><code>all()</code></h4>
<p><code>all</code> 方法返回代表集合的底层数组：</p>
<pre><code>collect([1, 2, 3])-&gt;all();

// [1, 2, 3]
</code></pre>
<h4 id="average"><code>average()</code></h4>
<p><code>avg</code> 方法的别名。</p>
<h4 id="avg"><code>avg()</code></h4>
<p><code>avg</code> 方法返回指定键的 平均值：</p>
<pre><code>$average = collect([['foo' =&gt; 10], ['foo' =&gt; 10], ['foo' =&gt; 20], ['foo' =&gt; 40]])-&gt;avg('foo');

// 20

$average = collect([1, 1, 2, 4])-&gt;avg();

// 2
</code></pre>
<h4 id="chunk"><code>chunk()</code></h4>
<p><code>chunk</code> 方法把集合分割成多个指定大小的较小集合：</p>
<pre><code>$collection = collect([1, 2, 3, 4, 5, 6, 7]);

$chunks = $collection-&gt;chunk(4);

$chunks-&gt;toArray();

// [[1, 2, 3, 4], [5, 6, 7]]
</code></pre>
<p>当使用如 Bootstrap 那样的栅格系统时，该方法在 视图 中相当有用。想象一下你有个想在栅格显示的Eloquent 模型：</p>
<pre><code>@foreach ($products-&gt;chunk(3) as $chunk)
    &lt;div class=&quot;row&quot;&gt;
        @foreach ($chunk as $product)
            &lt;div class=&quot;col-xs-4&quot;&gt;{{ $product-&gt;name }}&lt;/div&gt;
        @endforeach
    &lt;/div&gt;
@endforeach
</code></pre>
<h4 id="collapse"><code>collapse()</code></h4>
<p><code>collapse</code> 方法把一个多数组集合坍缩为单个扁平的集合：</p>
<pre><code>$collection = collect([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);

$collapsed = $collection-&gt;collapse();

$collapsed-&gt;all();

// [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<h4 id="combine"><code>combine()</code></h4>
<p><code>combine</code> 方法将一个集合的值作为键，与另一个数组或集合的值进行结合：</p>
<pre><code>$collection = collect(['name', 'age']);

$combined = $collection-&gt;combine(['George', 29]);

$combined-&gt;all();

// ['name' =&gt; 'George', 'age' =&gt; 29]
</code></pre>
<h4 id="collect"><code>collect()</code></h4>
<p><code>collect</code> 方法返回一个包含当前集合所含元素的新 <code>Collection</code> 实例：</p>
<pre><code>$collectionA = collect([1, 2, 3]);

$collectionB = $collectionA-&gt;collect();

$collectionB-&gt;all();

// [1, 2, 3]
</code></pre>
<p><code>collect</code> 方法从根本上对将 懒集合 转换为标准 <code>Collection</code> 实例有用:</p>
<pre><code>$lazyCollection = LazyCollection::make(function () {
    yield 1;
    yield 2;
    yield 3;
});

$collection = $lazyCollection-&gt;collect();

get_class($collection);

// 'Illuminate\Support\Collection'

$collection-&gt;all();

// [1, 2, 3]
</code></pre>
<h4 id="concat"><code>concat()</code></h4>
<p><code>concat</code> 方法在集合的末端附加指定的 <code>数组</code> 或集合值：</p>
<pre><code>$collection = collect(['John Doe']);

$concatenated = $collection-&gt;concat(['Jane Doe'])-&gt;concat(['name' =&gt; 'Johnny Doe']);

$concatenated-&gt;all();

// ['John Doe', 'Jane Doe', 'Johnny Doe']
</code></pre>
<h4 id="contains"><code>contains()</code></h4>
<p><code>contains</code> 方法检查集合有否包含指定的元素：</p>
<pre><code>$collection = collect(['name' =&gt; 'Desk', 'price' =&gt; 100]);

$collection-&gt;contains('Desk');

// true

$collection-&gt;contains('New York');

// false
</code></pre>
<p>你也可以传递一个键 / 值对给 <code>contains</code> 方法，它将检查集合有否存在指定的键 / 值对：</p>
<pre><code>$collection = collect([
    ['product' =&gt; 'Desk', 'price' =&gt; 200],
    ['product' =&gt; 'Chair', 'price' =&gt; 100],
]);

$collection-&gt;contains('product', 'Bookcase');

// false
</code></pre>
<p>最后，你也可以传递一个回调函数给 <code>contains</code> 方法去执行你的真值检验：</p>
<pre><code>$collection = collect([1, 2, 3, 4, 5]);

$collection-&gt;contains(function ($value, $key) {
    return $value &gt; 5;
});

// false
</code></pre>
<p><code>contains</code> 方法用 “松散” 比较检查元素值，意味着整数值的字符串会被视同等值的整数。用 <code>containsStrict</code> 方法使用 “严格” 比较过滤。</p>
<h4 id="containsstrict"><code>containsStrict()</code></h4>
<p>这个方法和 <code>contains</code> 方法类似；但是它却是使用了「严格」比较来比较所有的值。</p>
<h4 id="count"><code>count()</code></h4>
<p><code>count</code> 方法返回这个集合内集合项的总数量：</p>
<pre><code>$collection = collect([1, 2, 3, 4]);

$collection-&gt;count();

// 4
</code></pre>
<h4 id="countby"><code>countBy()</code></h4>
<p><code>countBy</code> 方法计算集合中每个值的出现次数。默认情况下，该方法计算每个元素的出现次数：</p>
<pre><code>$collection = collect([1, 2, 2, 2, 3]);

$counted = $collection-&gt;countBy();

$counted-&gt;all();

// [1 =&gt; 1, 2 =&gt; 3, 3 =&gt; 1]
</code></pre>
<p>但是，你也可以向 <code>countBy</code> 传递一个回调函数来计算自定义的值出现的次数:</p>
<pre><code>$collection = collect(['alice@gmail.com', 'bob@yahoo.com', 'carlos@gmail.com']);

$counted = $collection-&gt;countBy(function ($email) {
    return substr(strrchr($email, &quot;@&quot;), 1);
});

$counted-&gt;all();

// ['gmail.com' =&gt; 2, 'yahoo.com' =&gt; 1]
</code></pre>
<h4 id="crossjoin"><code>crossJoin()</code></h4>
<p><code>crossJoin</code> 方法交叉连接指定数组或集合的值，返回所有可能排列的笛卡尔积:</p>
<pre><code>$collection = collect([1, 2]);

$matrix = $collection-&gt;crossJoin(['a', 'b']);

$matrix-&gt;all();

/*
    [
        [1, 'a'],
        [1, 'b'],
        [2, 'a'],
        [2, 'b'],
    ]
*/

$collection = collect([1, 2]);

$matrix = $collection-&gt;crossJoin(['a', 'b'], ['I', 'II']);

$matrix-&gt;all();

/*
    [
        [1, 'a', 'I'],
        [1, 'a', 'II'],
        [1, 'b', 'I'],
        [1, 'b', 'II'],
        [2, 'a', 'I'],
        [2, 'a', 'II'],
        [2, 'b', 'I'],
        [2, 'b', 'II'],
    ]
*/
</code></pre>
<h4 id="dd"><code>dd()</code></h4>
<p><code>dd</code> 方法用于打印集合元素并中断脚本执行：</p>
<pre><code>$collection = collect(['John Doe', 'Jane Doe']);

$collection-&gt;dd();

/*
    Collection {
        #items: array:2 [
            0 =&gt; &quot;John Doe&quot;
            1 =&gt; &quot;Jane Doe&quot;
        ]
    }
*/
</code></pre>
<p>如果你不想中断执行脚本，请使用 <code>dump</code> 方法替代。</p>
<h4 id="diff"><code>diff()</code></h4>
<p><code>diff</code> 方法将集合与其它集合或者 PHP 数组进行值的比较。然后返回原集合中存在而指定集合中不存在的值：</p>
<pre><code>$collection = collect([1, 2, 3, 4, 5]);

$diff = $collection-&gt;diff([2, 4, 6, 8]);

$diff-&gt;all();

// [1, 3, 5]
</code></pre>
<h4 id="diffassoc"><code>diffAssoc()</code></h4>
<p><code>diffAssoc</code> 方法与另外一个集合或基于 PHP 数组的键 / 值对（<code>keys and values</code>）进行比较。这个方法将会返回原集合不存在于指定集合的键 / 值对：</p>
<pre><code>$collection = collect([
    'color' =&gt; 'orange',
    'type' =&gt; 'fruit',
    'remain' =&gt; 6
]);

$diff = $collection-&gt;diffAssoc([
    'color' =&gt; 'yellow',
    'type' =&gt; 'fruit',
    'remain' =&gt; 3,
    'used' =&gt; 6,
]);

$diff-&gt;all();

// ['color' =&gt; 'orange', 'remain' =&gt; 6]
</code></pre>
<h4 id="diffkeys"><code>diffKeys()</code></h4>
<p><code>diffKeys</code> 方法和另外一个集合或 PHP 数组的键（<code>keys</code>）进行比较，然后返回原集合中存在而指定集合中不存在键所对应的键 / 值对：</p>
<pre><code>$collection = collect([
    'one' =&gt; 10,
    'two' =&gt; 20,
    'three' =&gt; 30,
    'four' =&gt; 40,
    'five' =&gt; 50,
]);

$diff = $collection-&gt;diffKeys([
    'two' =&gt; 2,
    'four' =&gt; 4,
    'six' =&gt; 6,
    'eight' =&gt; 8,
]);

$diff-&gt;all();

// ['one' =&gt; 10, 'three' =&gt; 30, 'five' =&gt; 50]
</code></pre>
<h4 id="dump"><code>dump()</code></h4>
<p><code>dump</code> 方法用于打印集合项：</p>
<pre><code>$collection = collect(['John Doe', 'Jane Doe']);

$collection-&gt;dump();

/*
    Collection {
        #items: array:2 [
            0 =&gt; &quot;John Doe&quot;
            1 =&gt; &quot;Jane Doe&quot;
        ]
    }
*/
</code></pre>
<p>如果要在打印集合后终止执行脚本，请使用 <code>dd</code> 方法代替。</p>
<h4 id="duplicates"><code>duplicates()</code></h4>
<p><code>duplicates</code> 方法从集合中检索并返回重复的值：</p>
<pre><code>$collection = collect(['a', 'b', 'a', 'c', 'b']);

$collection-&gt;duplicates();

// [2 =&gt; 'a', 4 =&gt; 'b']
</code></pre>
<p>如果集合包含数组或对象，则可以传递希望检查重复值的属性的键：</p>
<pre><code>$employees = collect([
    ['email' =&gt; 'abigail@example.com', 'position' =&gt; 'Developer'],
    ['email' =&gt; 'james@example.com', 'position' =&gt; 'Designer'],
    ['email' =&gt; 'victoria@example.com', 'position' =&gt; 'Developer'],
])

$employees-&gt;duplicates('position');

// [2 =&gt; 'Developer']
</code></pre>
<h4 id="duplicatesstrict"><code>duplicatesStrict()</code></h4>
<p>此方法与 <code>duplicates</code> 方法具有相同的签名；但是，所有值都以「严格」的方式进行比较。</p>
<h4 id="each"><code>each()</code></h4>
<p><code>each</code> 方法用于循环集合项并将其传递到回调函数中：</p>
<pre><code>$collection-&gt;each(function ($item, $key) {
    //
});
</code></pre>
<p>如果你想中断对集合项的循环，那么就在你的回调函数中返回 <code>false</code> ：</p>
<pre><code>$collection-&gt;each(function ($item, $key) {
    if (/* some condition */) {
        return false;
    }
});
</code></pre>
<h4 id="eachspread"><code>eachSpread()</code></h4>
<p><code>eachSpread</code> 方法用于循环集合项，将每个嵌套集合项的值传递给回调函数：</p>
<pre><code>$collection = collect([['John Doe', 35], ['Jane Doe', 33]]);

$collection-&gt;eachSpread(function ($name, $age) {
    //
});
</code></pre>
<p>你可以通过在回调函数里返回 <code>false</code> 来中断循环：</p>
<pre><code>$collection-&gt;eachSpread(function ($name, $age) {
    return false;
});
</code></pre>
<h4 id="every"><code>every()</code></h4>
<p><code>every</code> 方法可用于验证集合中的每一个元素是否通过指定的条件测试：</p>
<pre><code>collect([1, 2, 3, 4])-&gt;every(function ($value, $key) {
    return $value &gt; 2;
});

// false
</code></pre>
<p>如果集合为空， <code>every</code> 将返回 true ：<br>
$collection = collect([]);</p>
<pre><code>$collection-&gt;every(function ($value, $key) {
    return $value &gt; 2;
});

// true
</code></pre>
<h4 id="except"><code>except()</code></h4>
<p><code>except</code> 方法返回集合中除了指定键之外的所有集合项：</p>
<pre><code>$collection = collect(['product_id' =&gt; 1, 'price' =&gt; 100, 'discount' =&gt; false]);

$filtered = $collection-&gt;except(['price', 'discount']);

$filtered-&gt;all();

// ['product_id' =&gt; 1]
</code></pre>
<p>与 <code>except</code> 对应的是 only 方法。</p>
<h4 id="filter"><code>filter()</code></h4>
<p><code>filter</code> 方法使用给定的回调函数过滤集合，只保留那些通过指定条件测试的集合项：</p>
<pre><code>$collection = collect([1, 2, 3, 4]);

$filtered = $collection-&gt;filter(function ($value, $key) {
    return $value &gt; 2;
});

$filtered-&gt;all();

// [3, 4]
</code></pre>
<p>如果没有提供回调函数，集合中所有返回 <code>false</code> 的元素都会被移除：</p>
<pre><code>$collection = collect([1, 2, 3, null, false, '', 0, []]);

$collection-&gt;filter()-&gt;all();

// [1, 2, 3]
</code></pre>
<p><code>filter</code> 对应的是 reject 方法。</p>
<h4 id="first"><code>first()</code></h4>
<p><code>first</code> 方法返回集合中通过指定条件测试的第一个元素：</p>
<pre><code>collect([1, 2, 3, 4])-&gt;first(function ($value, $key) {
    return $value &gt; 2;
});

// 3
</code></pre>
<p>你也可以不传入参数调用 <code>first</code> 方法来获取集合中的第一个元素。如果集合为空，则会返回 <code>null</code> ：</p>
<pre><code>collect([1, 2, 3, 4])-&gt;first();

// 1
</code></pre>
<h4 id="firstwhere"><code>firstWhere()</code></h4>
<p><code>firstWhere</code> 方法返回集合中含有指定键 / 值对的第一个元素：</p>
<pre><code>$collection = collect([
    ['name' =&gt; 'Regena', 'age' =&gt; null],
    ['name' =&gt; 'Linda', 'age' =&gt; 14],
    ['name' =&gt; 'Diego', 'age' =&gt; 23],
    ['name' =&gt; 'Linda', 'age' =&gt; 84],
]);

$collection-&gt;firstWhere('name', 'Linda');

// ['name' =&gt; 'Linda', 'age' =&gt; 14]
</code></pre>
<p>你也可以使用运算符来调用 <code>firstWhere</code> 方法：</p>
<pre><code>$collection-&gt;firstWhere('age', '&gt;=', 18);

// ['name' =&gt; 'Diego', 'age' =&gt; 23]
</code></pre>
<p>和 <code>where</code> 方法一样，你可以将一个参数传递给 <code>firstWhere</code> 方法。在这种情况下， <code>firstWhere</code> 方法将返回指定键的值为「真」的第一个集合项：</p>
<pre><code>$collection-&gt;firstWhere('age');

// ['name' =&gt; 'Linda', 'age' =&gt; 14]
</code></pre>
<h4 id="flatmap"><code>flatMap()</code></h4>
<p><code>flatMap</code> 方法遍历集合并将其中的每个值传递到给定的回调函数。可以通过回调函数修改集合项并返回它们，从而形成一个被修改过的新集合。然后，集合转化的数组是同级的：</p>
<pre><code>$collection = collect([
    ['name' =&gt; 'Sally'],
    ['school' =&gt; 'Arkansas'],
    ['age' =&gt; 28]
]);

$flattened = $collection-&gt;flatMap(function ($values) {
    return array_map('strtoupper', $values);
});

$flattened-&gt;all();

// ['name' =&gt; 'SALLY', 'school' =&gt; 'ARKANSAS', 'age' =&gt; '28'];
</code></pre>
<h4 id="flip"><code>flip()</code></h4>
<p><code>flip</code> 方法将集合的键和对应的值进行互换：</p>
<pre><code>$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);

$flipped = $collection-&gt;flip();

$flipped-&gt;all();

// ['taylor' =&gt; 'name', 'laravel' =&gt; 'framework']
</code></pre>
<h4 id="forget"><code>forget()</code></h4>
<p><code>forget</code> 方法将通过指定的键来移除集合中对应的内容：</p>
<pre><code>$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);

$collection-&gt;forget('name');

$collection-&gt;all();

// ['framework' =&gt; 'laravel']
</code></pre>
<p>注意：与大多数集合的方法不同的是， <code>forget</code> 不会返回修改后的新集合；它会直接修改原集合。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[辅助函数]]></title>
        <id>http://xiewxin.github.io/post/fu-zhu-han-shu/</id>
        <link href="http://xiewxin.github.io/post/fu-zhu-han-shu/">
        </link>
        <updated>2020-06-07T09:10:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="辅助函数">辅助函数</h1>
<h2 id="可用方法">可用方法</h2>
<h3 id="数组对象">数组&amp;对象</h3>
<p>Arr::add<br>
Arr::collapse<br>
Arr::crossJoin<br>
Arr::divide<br>
Arr::dot<br>
Arr::except<br>
Arr::first<br>
Arr::flatten<br>
Arr::forget<br>
Arr::get<br>
Arr::has<br>
Arr::isAssoc<br>
Arr::last<br>
Arr::only<br>
Arr::pluck<br>
Arr::prepend<br>
Arr::pull<br>
Arr::random<br>
Arr::query<br>
Arr::set<br>
Arr::shuffle<br>
Arr::sort<br>
Arr::sortRecursive<br>
Arr::where<br>
Arr::wrap<br>
data_fill<br>
data_get<br>
data_set<br>
head<br>
last</p>
<h3 id="路徑">路徑</h3>
<p>app_path<br>
base_path<br>
config_path<br>
database_path<br>
mix<br>
public_path</p>
<p>resource_path</p>
<p>storage_path</p>
<h3 id="字符串">字符串</h3>
<p>__</p>
<p>class_basename<br>
e<br>
preg_replace_array<br>
Str::after<br>
Str::afterLast<br>
Str::before<br>
Str::beforeLast<br>
Str::camel<br>
Str::contains<br>
Str::containsAll<br>
Str::endsWith<br>
Str::finish<br>
Str::is<br>
Str::isUuid<br>
Str::kebab<br>
Str::limit<br>
Str::orderedUuid<br>
Str::plural<br>
Str::random<br>
Str::replaceArray<br>
Str::replaceFirst<br>
Str::replaceLast<br>
Str::singular</p>
<p>Str::slug<br>
Str::snake<br>
Str::start<br>
Str::startsWith<br>
Str::studly<br>
Str::title<br>
Str::ucfirst<br>
Str::uuid<br>
Str::words<br>
trans<br>
trans_choice</p>
<h2 id="方法列表">方法列表</h2>
<h3 id="数组对象-2">数组&amp;对象</h3>
<h4 id="arradd-collection-method-first-collection-method"><code>Arr::add()</code> {#collection-method .first-collection-method}</h4>
<p>如果给定的键在数组中不存在或数组被设置为 <code>null</code> ，那么 <code>Arr::add</code> 函数将会把给定的键值对添加到数组中：</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::add(['name' =&gt; 'Desk'], 'price', 100);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]

$array = Arr::add(['name' =&gt; 'Desk', 'price' =&gt; null], 'price', 100);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<h4 id="arrcollapse-collection-method"><code>Arr::collapse()</code> {#collection-method}</h4>
<p><code>Arr::collapse</code> 函数将多个数组合并为一个数组:</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);

// [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<h4 id="arrcrossjoin-collection-method">Arr::crossJoin() {#collection-method}</h4>
<p><code>Arr :: crossJoin</code> 函数交叉连接给定的数组，返回具有所有可能排列的笛卡尔乘积：</p>
<pre><code>use Illuminate\Support\Arr;

$matrix = Arr::crossJoin([1, 2], ['a', 'b']);

/*
    [
        [1, 'a'],
        [1, 'b'],
        [2, 'a'],
        [2, 'b'],
    ]
*/

$matrix = Arr::crossJoin([1, 2], ['a', 'b'], ['I', 'II']);

/*
    [
        [1, 'a', 'I'],
        [1, 'a', 'II'],
        [1, 'b', 'I'],
        [1, 'b', 'II'],
        [2, 'a', 'I'],
        [2, 'a', 'II'],
        [2, 'b', 'I'],
        [2, 'b', 'II'],
    ]
*/
</code></pre>
<h4 id="arrdivide-collection-method"><code>Arr::divide()</code> {#collection-method}</h4>
<p><code>Arr::divide</code> 函数返回一个二维数组，一个值包含原始数组的键，另一个值包含原始数组的值</p>
<pre><code>use Illuminate\Support\Arr;

[$keys, $values] = Arr::divide(['name' =&gt; 'Desk']);

// $keys: ['name']

// $values: ['Desk']
</code></pre>
<h4 id="arrdot-collection-method">Arr::dot() {#collection-method}</h4>
<p><code>Arr::dot</code> 函数将多维数组中所有的键平铺到一维数组中，新数组使用「.」符号表示层级包含关系：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$flattened = Arr::dot($array);

// ['products.desk.price' =&gt; 100]
</code></pre>
<h4 id="arrexcept-collection-method">Arr::except() {#collection-method}</h4>
<p><code>Arr::except</code> 函数从数组中删除指定的键值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100];

$filtered = Arr::except($array, ['price']);

// ['name' =&gt; 'Desk']
</code></pre>
<h4 id="arrfirst-collection-method">Arr::first() {#collection-method}</h4>
<p><code>Arr::first</code> 函数返回数组中通过真值测试的第一个元素：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, 200, 300];

$first = Arr::first($array, function ($value, $key) {
    return $value &gt;= 150;
});

// 200
</code></pre>
<p>将默认值作为第三个参数传递给该方法， 如果数组中没有值通过真值测试，则返回默认值：</p>
<pre><code>use Illuminate\Support\Arr;

$first = Arr::first($array, $callback, $default);
</code></pre>
<h4 id="arrflatten-collection-method">Arr::flatten() {#collection-method}</h4>
<p><code>Arr::flatten</code> 函数将多维数组中数组的值取出平铺为一维数组：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Joe', 'languages' =&gt; ['PHP', 'Ruby']];

$flattened = Arr::flatten($array);

// ['Joe', 'PHP', 'Ruby']
</code></pre>
<h4 id="arrforget-collection-method">Arr::forget() {#collection-method}</h4>
<p><code>Arr::forget</code> 函数使用「.」符号从深度嵌套的数组中删除给定的键值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

Arr::forget($array, 'products.desk');

// ['products' =&gt; []]
</code></pre>
<h4 id="arrget-collection-method">Arr::get() {#collection-method}</h4>
<p><code>Arr::get</code> 函数使用「.」符号从深度嵌套的数组中根据指定键检索值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$price = Arr::get($array, 'products.desk.price');

// 100
</code></pre>
<p><code>Arr::get</code> 函数也接受一个默认值，如果没有找到特定的键，将返回默认值：</p>
<pre><code>use Illuminate\Support\Arr;

$discount = Arr::get($array, 'products.desk.discount', 0);

// 0
</code></pre>
<h4 id="arrhas-collection-method">Arr::has() {#collection-method}</h4>
<p><code>Arr::has</code> 函数使用「.」符号查找数组中是否存在指定的一个或多个键：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]];

$contains = Arr::has($array, 'product.name');

// true

$contains = Arr::has($array, ['product.price', 'product.discount']);

// false
</code></pre>
<h4 id="arrisassoc-collection-method">Arr::isAssoc() {#collection-method}</h4>
<p>如果给定数组是关联数组，则 <code>Arr::isAssoc</code> 函数返回 <code>true</code> 。如果数组没有以零开头的连续数字键，则将其视为 “关联”。</p>
<pre><code>use Illuminate\Support\Arr;

$isAssoc = Arr::isAssoc(['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]]);

// true

$isAssoc = Arr::isAssoc([1, 2, 3]);

// false
</code></pre>
<h4 id="arrlast-collection-method">Arr::last() {#collection-method}</h4>
<p><code>Arr::last</code> 函数返回数组中满足指定条件的最后一个元素：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, 200, 300, 110];

$last = Arr::last($array, function ($value, $key) {
    return $value &gt;= 150;
});

// 300
</code></pre>
<p>将默认值作为第三个参数传递给该方法，如果没有值通过真值测试，则返回该默认值：</p>
<pre><code>use Illuminate\Support\Arr;

$last = Arr::last($array, $callback, $default);
</code></pre>
<h4 id="arronly-collection-method">Arr::only() {#collection-method}</h4>
<p><code>Arr::only</code> 函数只返回给定数组中指定的键值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100, 'orders' =&gt; 10];

$slice = Arr::only($array, ['name', 'price']);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<h4 id="arrpluck-collection-method">Arr::pluck() {#collection-method}</h4>
<p><code>Arr::pluck</code> 函数从数组中检索给定键的所有值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['developer' =&gt; ['id' =&gt; 1, 'name' =&gt; 'Taylor']],
    ['developer' =&gt; ['id' =&gt; 2, 'name' =&gt; 'Abigail']],
];

$names = Arr::pluck($array, 'developer.name');

// ['Taylor', 'Abigail']
</code></pre>
<p>你也可以指定获取的结果的键：</p>
<pre><code>use Illuminate\Support\Arr;

$names = Arr::pluck($array, 'developer.name', 'developer.id');

// [1 =&gt; 'Taylor', 2 =&gt; 'Abigail']
</code></pre>
<h4 id="arrprepend-collection-method">Arr::prepend() {#collection-method}</h4>
<p><code>Arr::prepend</code> 函数将一个值插入到数组的开始位置：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['one', 'two', 'three', 'four'];

$array = Arr::prepend($array, 'zero');

// ['zero', 'one', 'two', 'three', 'four']
</code></pre>
<p>如果需要，你可以指定你插入值的键：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['price' =&gt; 100];

$array = Arr::prepend($array, 'Desk', 'name');

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<h4 id="arrpull-collection-method">Arr::pull() {#collection-method}</h4>
<p><code>Arr::pull</code> 函数从数组中返回指定键的值并删除此键／值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100];

$name = Arr::pull($array, 'name');

// $name: Desk

// $array: ['price' =&gt; 100]
</code></pre>
<p>默认值可以作为第三个参数传递给该方法，如果键不存在，则返回该值：</p>
<pre><code>use Illuminate\Support\Arr;

$value = Arr::pull($array, $key, $default);
</code></pre>
<h4 id="arrrandom-collection-method">Arr::random() {#collection-method}</h4>
<p><code>Arr::random</code> 函数从数组中随机返回一个值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [1, 2, 3, 4, 5];

$random = Arr::random($array);

// 4 - (retrieved randomly)
</code></pre>
<p>你也可以将返回值的数量作为可选的第二个参数传递给该方法，请注意，提供这个参数会返回一个数组，即使是你只需要一项：</p>
<pre><code>use Illuminate\Support\Arr;

$items = Arr::random($array, 2);

// [2, 5] - (retrieved randomly)
</code></pre>
<h4 id="arrquery-collection-method">Arr::query() {#collection-method}</h4>
<p><code>Arr::query</code> 函数将数组转换为查询字符串：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Taylor', 'order' =&gt; ['column' =&gt; 'created_at', 'direction' =&gt; 'desc']];

Arr::query($array);

// name=Taylor&amp;order[column]=created_at&amp;order[direction]=desc
</code></pre>
<h4 id="arrset-collection-method">Arr::set() {#collection-method}</h4>
<p><code>Arr::set</code> 函数使用「.」符号在多维数组中设置指定键的值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

Arr::set($array, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 200]]]
</code></pre>
<h4 id="arrshuffle-collection-method">Arr::shuffle() {#collection-method}</h4>
<p><code>Arr::shuffle</code> 函数将数组中值进行随机排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::shuffle([1, 2, 3, 4, 5]);

// [3, 2, 5, 1, 4] - (generated randomly)
</code></pre>
<h4 id="arrsort-collection-method">Arr::sort() {#collection-method}</h4>
<p><code>Arr::sort</code> 函数根据数组的值对数组进行排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['Desk', 'Table', 'Chair'];

$sorted = Arr::sort($array);

// ['Chair', 'Desk', 'Table']
</code></pre>
<p>你也可以根据给定闭包返回的结果对数组进行排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['name' =&gt; 'Desk'],
    ['name' =&gt; 'Table'],
    ['name' =&gt; 'Chair'],
];

$sorted = array_values(Arr::sort($array, function ($value) {
    return $value['name'];
}));

/*
    [
        ['name' =&gt; 'Chair'],
        ['name' =&gt; 'Desk'],
        ['name' =&gt; 'Table'],
    ]
*/
</code></pre>
<h4 id="arrsortrecursive-collection-method">Arr::sortRecursive() {#collection-method}</h4>
<p><code>Arr::sortRecursive</code> 函数使用 <code>sort</code> 函数对数值子数组进行递归排序，使用 <code>ksort</code> 函数对关联子数组进行递归排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['Roman', 'Taylor', 'Li'],
    ['PHP', 'Ruby', 'JavaScript'],
    ['one' =&gt; 1, 'two' =&gt; 2, 'three' =&gt; 3],
];

$sorted = Arr::sortRecursive($array);

/*
    [
        ['JavaScript', 'PHP', 'Ruby'],
        ['one' =&gt; 1, 'three' =&gt; 3, 'two' =&gt; 2],
        ['Li', 'Roman', 'Taylor'],
    ]
*/
</code></pre>
<h4 id="arrwhere-collection-method">Arr::where() {#collection-method}</h4>
<p><code>Arr::where</code> 函数使用给定闭包返回的结果过滤数组：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, '200', 300, '400', 500];

$filtered = Arr::where($array, function ($value, $key) {
    return is_string($value);
});

// [1 =&gt; '200', 3 =&gt; '400']
</code></pre>
<h4 id="arrwrap-collection-method">Arr::wrap() {#collection-method}</h4>
<p><code>Arr::wrap</code> 方法可以将给定值转换为一个数组。如果给定值已经是一个数组，将不会进行转换：</p>
<pre><code>use Illuminate\Support\Arr;

$string = 'Laravel';

$array = Arr::wrap($string);

// ['Laravel']
</code></pre>
<p>如果给定值是 <code>null</code> ，将返回一个空数组：</p>
<pre><code>use Illuminate\Support\Arr;

$nothing = null;

$array = Arr::wrap($nothing);

// []
</code></pre>
<h4 id="data_fill-collection-method">data_fill() {#collection-method}</h4>
<p><code>data_fill</code> 函数以 . 形式给嵌套数组或对象中设置缺省值：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_fill($data, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]]

data_fill($data, 'products.desk.discount', 10);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100, 'discount' =&gt; 10]]]
</code></pre>
<p>这个函数也可以接收一个 <code>*</code> 作为通配符，并对相应位置进行填充：</p>
<pre><code>$data = [
    'products' =&gt; [
        ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
        ['name' =&gt; 'Desk 2'],
    ],
];

data_fill($data, 'products.*.price', 200);

/*
    [
        'products' =&gt; [
            ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
            ['name' =&gt; 'Desk 2', 'price' =&gt; 200],
        ],
    ]
*/
</code></pre>
<h4 id="data_get-collection-method">data_get() {#collection-method}</h4>
<p><code>data_get</code> 函数可使用 . 形式获得嵌套函数或者对象中的值：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$price = data_get($data, 'products.desk.price');

// 100
</code></pre>
<p>当找不到指定键名时，<code>data_get</code> 函数也支持返回一个默认值：</p>
<pre><code>$discount = data_get($data, 'products.desk.discount', 0);

// 0
</code></pre>
<p>这个函数也可以接受一个 <code>*</code> 作为通配符，以匹配数组或对象中任意键名：</p>
<pre><code>$data = [
    'product-one' =&gt; ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
    'product-two' =&gt; ['name' =&gt; 'Desk 2', 'price' =&gt; 150],
];

data_get($data, '*.name');

// ['Desk 1', 'Desk 2'];
</code></pre>
<h4 id="data_set-collection-method">data_set() {#collection-method}</h4>
<p><code>data_set</code> 函数可以用 . 形式给嵌套函数或对象赋值：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_set($data, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 200]]]
</code></pre>
<p>这个函数也支持使用 <code>*</code> 作为通配符给相应键名赋值：</p>
<pre><code>$data = [
    'products' =&gt; [
        ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
        ['name' =&gt; 'Desk 2', 'price' =&gt; 150],
    ],
];

data_set($data, 'products.*.price', 200);

/*
    [
        'products' =&gt; [
            ['name' =&gt; 'Desk 1', 'price' =&gt; 200],
            ['name' =&gt; 'Desk 2', 'price' =&gt; 200],
        ],
    ]
*/
</code></pre>
<p>通常情况下，已存在的值将会被覆盖。如果只是希望设置一个目前不存在的值，你可以增加一个 <code>false</code> 作为函数的第四个参数：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_set($data, 'products.desk.price', 200, false);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]]
</code></pre>
<h4 id="head-collection-method">head() {#collection-method}</h4>
<p><code>head</code> 函数将返回数组中的第一个值：</p>
<pre><code>$array = [100, 200, 300];

$first = head($array);

// 100
</code></pre>
<h4 id="last-collection-method">last() {#collection-method}</h4>
<p><code>last</code> 返回给定数组的最后一个元素：</p>
<pre><code>$array = [100, 200, 300];

$last = last($array);

// 300
</code></pre>
<h3 id="路徑-2">路徑</h3>
<h4 id="app_path-collection-method"><code>app_path()</code> {#collection-method}</h4>
<p><code>app_path</code> 函数返回 <code>app</code> 目录的完整路径。 你也可以用 <code>app_path</code> 函数去生成应用程序目录下一个文件的完整路径：</p>
<pre><code>$path = app_path();

$path = app_path('Http/Controllers/Controller.php');
</code></pre>
<h4 id="base_path-collection-method"><code>base_path()</code> {#collection-method}</h4>
<p><code>base_path</code> 函数返回项目根目录的完整路径。 你也可以用 <code>base_path</code> 函数生成项目根目录下一个文件的完整路径：</p>
<pre><code>$path = base_path();

$path = base_path('vendor/bin');
</code></pre>
<h4 id="config_path-collection-method"><code>config_path()</code> {#collection-method}</h4>
<p><code>config_path</code> 函数返回 <code>config</code> 目录的完整路径。你也可以用 <code>config_path</code> 函数去生成应用程序配置目录下一个指定文件的完整路径：</p>
<pre><code>$path = config_path();

$path = config_path('app.php');
</code></pre>
<h4 id="database_path-collection-method"><code>database_path()</code> {#collection-method}</h4>
<p><code>database_path</code> 函数返回 <code>database</code> 目录的完整路径。 你也可以用 <code>database_path</code> 函数去生成 <code>database</code>目录下一个指定文件的完整路径：</p>
<pre><code>$path = database_path();

$path = database_path('factories/UserFactory.php');
</code></pre>
<h4 id="mix-collection-method"><code>mix()</code> {#collection-method}</h4>
<p><code>mix</code> 返回 <a href="https://learnku.com/docs/laravel/7.x/mix">版本化 MIX 文件</a> 的路径:</p>
<pre><code>$path = mix('css/app.css');
</code></pre>
<h4 id="public_path-collection-method"><code>public_path()</code> {#collection-method}</h4>
<p><code>public_path</code> 函数返回 <code>public</code> 目录的完整路径。 你也可以用 <code>public_path</code> 函数去生成 <code>public</code> 目录下一个指定文件的完整路径：</p>
<pre><code>$path = public_path();

$path = public_path('css/app.css');
</code></pre>
<h4 id="resource_path-collection-method"><code>resource_path()</code> {#collection-method}</h4>
<p><code>resource_path</code> 函数返回 <code>resources</code> 目录的完整路径。你也可以用 <code>resource_path</code> 函数去生成资源文件目录下的一个指定文件的完整路径：</p>
<pre><code>$path = resource_path();

$path = resource_path('sass/app.scss');
</code></pre>
<h4 id="storage_path"><code>storage_path()</code></h4>
<p><code>storage_path</code> 函数返回指向 “storage” 目录的绝对路径。还可以使用 <code>storage_path</code> 函数生成 <code>storage</code> 目录下给定文件的完整路径：</p>
<pre><code>$path = storage_path();

$path = storage_path('app/file.txt');
</code></pre>
<h3 id="字符串函数">字符串函数</h3>
<h4 id="__"><code>__()</code></h4>
<p><code>__</code>函数可使用 本地化文件 翻译指定的字符串或者键值：</p>
<pre><code>echo __('Welcome to our application');

echo __('messages.welcome');
</code></pre>
<p>如果指定的转换字符串或键不存在，<code>__</code> 函数将返回原来的值。即：如果 <code>messages.welcome</code> 键值不存在，则返回 <code>messages.welcome</code>。</p>
<h4 id="e"><code>e()</code></h4>
<p><code>e</code> 函数在指定字符串上运行 htmlentities 方法（double_encode 参数为 false）：</p>
<pre><code>echo e('&lt;html&gt;foo&lt;/html&gt;');

// &amp;lt;html&amp;gt;foo&amp;lt;/html&amp;gt;
</code></pre>
<h4 id="preg_replace_array"><code>preg_replace_array()</code></h4>
<p><code>preg_replace_array</code> 函数使用正则规则用给定数组替换字符串中的内容：</p>
<pre><code>$string = 'The event will take place between :start and :end';

$replaced = preg_replace_array('/:[a-z_]+/', ['8:30', '9:00'], $string);

// The event will take place between 8:30 and 9:00
</code></pre>
<h4 id="strafter"><code>Str::after()</code></h4>
<p><code>Str::after</code> 方法返回字符串中给定值之后的所有内容。如果字符串中不存在该值，则将返回整个字符串：</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::after('This is my name', 'This is');

// ' my name'
</code></pre>
<h4 id="strafterlast"><code>Str::afterLast()</code></h4>
<p><code>Str::afterLast</code> 方法返回字符串中给定值最后一次出现后的所有内容。如果字符串中不存在该值，则将返回整个字符串：</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::afterLast('App\Http\Controllers\Controller', '\\');

// 'Controller'
</code></pre>
<h4 id="strbefore-collection-method"><code>Str::before()</code> {#collection-method}</h4>
<p><code>Str::before</code> 方法返回字符串中给定值之前的所有内容：use Illuminate\Support\Str;</p>
<pre><code>$slice = Str::before('This is my name', 'my name');

// 'This is '
</code></pre>
<h4 id="strbeforelast"><code>Str::beforeLast()</code></h4>
<p><code>Str::beforeLast</code> 方法返回字符串中给定值最后出现之前的所有内容：</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::beforeLast('This is my name', 'is');

// 'This '
</code></pre>
<h4 id="strcamel"><code>Str::camel()</code></h4>
<p><code>Str::camel</code> 方法将给定字符串转换为 <code>camelCase</code>（驼峰式）：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::camel('foo_bar');

// fooBar
</code></pre>
<h4 id="strcontains-collection-method"><code>Str::contains()</code> {#collection-method}</h4>
<p><code>Str::contains</code> 方法判断给定的字符串是否包含给定的值（区分大小写）：</p>
<pre><code>use Illuminate\Support\Str;

$contains = Str::contains('This is my name', 'my');

// true
</code></pre>
<p>你也可以传递一个数组形式的值来判断给定的字符串中是否包含数组中的任意一个值：</p>
<pre><code>use Illuminate\Support\Str;

$contains = Str::contains('This is my name', ['my', 'foo']);

// true
</code></pre>
<h4 id="strcontainsall-collection-method"><code>Str::containsAll()</code> {#collection-method}</h4>
<p><code>Str::containsAll</code> 方法判断给定的字符串中是否包含给定的数组中所有的值：</p>
<pre><code>use Illuminate\Support\Str;

$containsAll = Str::containsAll('This is my name', ['my', 'name']);

// true
</code></pre>
<h4 id="strendswith-collection-method"><code>Str::endsWith()</code> {#collection-method}</h4>
<p><code>Str::endsWith</code> 方法判断给定的字符串是否以给定的值结尾：</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::endsWith('This is my name', 'name');

// true
</code></pre>
<p>你也可以传递一个数组形式的值来判断给定的字符串是否以数组中的任意一个值结尾：</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::endsWith('This is my name', ['name', 'foo']);

// true

$result = Str::endsWith('This is my name', ['this', 'foo']);

// false
</code></pre>
<h4 id="strfinish-collection-method"><code>Str::finish()</code> {#collection-method}</h4>
<p><code>Str::finish</code> 方法将给定的字符串以给定的值结尾返回（如果该字符串尚未以该值结尾）：</p>
<pre><code>use Illuminate\Support\Str;

$adjusted = Str::finish('this/string', '/');

// this/string/

$adjusted = Str::finish('this/string/', '/');

// this/string/
</code></pre>
<h4 id="stris-collection-method"><code>Str::is()</code> {#collection-method}</h4>
<p><code>Str::is</code> 方法判断给定的字符串是否匹配给定的模式，星号 <code>*</code> 可以用来表示通配符：</p>
<pre><code>use Illuminate\Support\Str;

$matches = Str::is('foo*', 'foobar');

// true

$matches = Str::is('baz*', 'foobar');

// false
</code></pre>
<h4 id="strucfirst-collection-method"><code>Str::ucfirst()</code> {#collection-method}</h4>
<p><code>Str::ucfirst</code> 方法将给定的字符串首字母大写并返回：</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::ucfirst('foo bar');

// Foo bar
</code></pre>
<h4 id="strisuuid-collection-method"><code>Str::isUuid()</code> {#collection-method}</h4>
<p><code>Str::isUuid</code> 方法用来确定给定的字符串是否为有效的 UUID：</p>
<pre><code>use Illuminate\Support\Str;

$isUuid = Str::isUuid('a0a2a2d2-0b87-4a18-83f2-2529882be2de');

// true

$isUuid = Str::isUuid('laravel');

// false
</code></pre>
<h4 id="strkebab-collection-method"><code>Str::kebab()</code> {#collection-method}</h4>
<p><code>Str::kebab</code> 方法将给定的「驼峰式」字符串转化为 kebab-case「短横式」字符串</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::kebab('fooBar');

// foo-bar
</code></pre>
<h4 id="strlimit-collection-method"><code>Str::limit()</code> {#collection-method}</h4>
<p><code>Str::limit</code> 方法按给定的长度截断给定的字符串：</p>
<pre><code>use Illuminate\Support\Str;

$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20);

// The quick brown fox...
</code></pre>
<p>你也可以传递第三个参数来改变将被追加到最后的字符串：</p>
<pre><code>use Illuminate\Support\Str;

$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20, ' (...)');

// The quick brown fox (...)
</code></pre>
<h4 id="strordereduuid-collection-method"><code>Str::orderedUuid()</code> {#collection-method}</h4>
<p><code>Str::orderedUuid</code> 方法高效生成一个可存储在索引数据库列中的「第一时间」 UUID：</p>
<pre><code>use Illuminate\Support\Str;

return (string) Str::orderedUuid();
</code></pre>
<h4 id="strplural-collection-method"><code>Str::plural()</code> {#collection-method}</h4>
<p><code>Str::plural</code> 函数将字符串转换为复数形式。该函数目前仅支持英文</p>
<pre><code>use Illuminate\Support\Str;

$plural = Str::plural('car');

// cars

$plural = Str::plural('child');

// children
</code></pre>
<p>你可以提供一个整数作为函数的第二个参数来检索字符串的单数或复数形式：</p>
<pre><code>use Illuminate\Support\Str;

$plural = Str::plural('child', 2);

// children

$plural = Str::plural('child', 1);

// child
</code></pre>
<h4 id="strrandom-collection-method"><code>Str::random()</code> {#collection-method}</h4>
<p><code>Str::random</code> 函数生成一个指定长度的随机字符串。这个函数用 PHP 的 <code>random_bytes</code> 函数：</p>
<pre><code>use Illuminate\Support\Str;

$random = Str::random(40);
</code></pre>
<h4 id="strreplacearray-collection-method"><code>Str::replaceArray()</code> {#collection-method}</h4>
<p><code>Str::replaceArray</code> 函数使用数组顺序替换字符串中的给定值：</p>
<pre><code>use Illuminate\Support\Str;

$string = 'The event will take place between ? and ?';

$replaced = Str::replaceArray('?', ['8:30', '9:00'], $string);

// 活动将在 8:30 至 9:00 之间进行
</code></pre>
<h4 id="strreplacefirst-collection-method"><code>Str::replaceFirst()</code> {#collection-method}</h4>
<p><code>Str::replaceFirst</code> 函数替换字符串中给定值的第一个匹配项：</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::replaceFirst('the', 'a', 'the quick brown fox jumps over the lazy dog');

// a quick brown fox jumps over the lazy dog
</code></pre>
<h4 id="strreplacelast-collection-method"><code>Str::replaceLast()</code> {#collection-method}</h4>
<p><code>Str::replaceLast</code> 函数替换字符串中最后一次出现的给定值：</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::replaceLast('the', 'a', 'the quick brown fox jumps over the lazy dog');

// the quick brown fox jumps over a lazy dog
</code></pre>
<h4 id="strsingular-collection-method"><code>Str::singular()</code> {#collection-method}</h4>
<p><code>Str::singular</code> 函数将字符串转换为单数形式。该函数目前仅支持英文：</p>
<pre><code>use Illuminate\Support\Str;

$singular = Str::singular('cars');

// car

$singular = Str::singular('children');

// child
</code></pre>
<h4 id="strslug-collection-method"><code>Str::slug()</code> {#collection-method}</h4>
<p><code>Str::slug</code> 函数将给定的字符串生成一个 URL 友好的 「slug」 ：</p>
<pre><code>use Illuminate\Support\Str;

$slug = Str::slug('Laravel 5 Framework', '-');

// laravel-5-framework
</code></pre>
<h4 id="strsnake-collection-method"><code>Str::snake()</code> {#collection-method}</h4>
<p><code>Str::snake</code> 函数将给定的字符串转换为 <code>snake_case</code>「蛇式」：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::snake('fooBar');

// foo_bar
</code></pre>
<h4 id="strstart-collection-method"><code>Str::start()</code> {#collection-method}</h4>
<p><code>Str::start</code> 函数将给定值添加到给定字符串的开始位置（如果字符串尚未以给定值开始）：</p>
<pre><code>use Illuminate\Support\Str;

$adjusted = Str::start('this/string', '/');

// /this/string

$adjusted = Str::start('/this/string', '/');

// /this/string
</code></pre>
<h4 id="strstartswith-collection-method"><code>Str::startsWith()</code> {#collection-method}</h4>
<p><code>Str::startsWith</code> 函数判断给定的字符串的开头是否是指定值：</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::startsWith('This is my name', 'This');

// true
</code></pre>
<h4 id="strstudly-collection-method"><code>Str::studly()</code> {#collection-method}</h4>
<p><code>Str::studly</code> 函数将给定的字符串转换为 「变种驼峰命名」：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::studly('foo_bar');

// FooBar
</code></pre>
<h4 id="strtitle-collection-method"><code>Str::title()</code> {#collection-method}</h4>
<p><code>Str::title</code> 函数将给定的字符串转换为「首字母大写」：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::title('a nice title uses the correct case');

// A Nice Title Uses The Correct Case
</code></pre>
<h4 id="struuid-collection-method"><code>Str::uuid()</code> {#collection-method}</h4>
<p><code>Str::uuid</code> 方法生成一个 UUID（版本 4）：</p>
<pre><code>use Illuminate\Support\Str;

return (string) Str::uuid();
</code></pre>
<h4 id="strwords-collection-method"><code>Str::words()</code> {#collection-method}</h4>
<p><code>Str::words</code> 函数限制字符串中的单词数：</p>
<pre><code>use Illuminate\Support\Str;

return Str::words('Perfectly balanced, as all things should be.', 3, ' &gt;&gt;&gt;');

// Perfectly balanced, as &gt;&gt;&gt;
</code></pre>
<h4 id="trans-collection-method"><code>trans()</code> {#collection-method}</h4>
<p><code>trans</code> 函数使用你的 本地文件（如：/xiewxin.github.io/docs/laravel/resources/lang/en.json） 转换给定的翻译密钥</p>
<pre><code>echo trans('messages.welcome');
</code></pre>
<p>如果指定的翻译键不存在，则 <code>trans</code> 方法会简单地返回给定的键。所以，就上面的例子而言，如果翻译键不存在， <code>trans</code> 方法会返回 <code>messages.welcome</code></p>
<h4 id="trans_choice-collection-method"><code>trans_choice()</code> {#collection-method}</h4>
<p><code>trans_choice</code> 函数根据词形变化来翻译给定的翻译键：</p>
<p>如果指定的翻译键不存在， <code>trans_choice</code> 方法会简单地返回给定的键。所以，按照上面的例子，如果翻译键不存在，<code>trans_choice</code> 方法会返回 <code>messages.notifications</code>。</p>
]]></content>
    </entry>
</feed>