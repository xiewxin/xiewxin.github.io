<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://xiewxin.github.io/</id>
    <title>xiewixn blog</title>
    <updated>2020-08-23T07:25:13.386Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://xiewxin.github.io/"/>
    <link rel="self" href="http://xiewxin.github.io/atom.xml"/>
    <subtitle>闲庭若步</subtitle>
    <logo>http://xiewxin.github.io/images/avatar.png</logo>
    <icon>http://xiewxin.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, xiewixn blog</rights>
    <entry>
        <title type="html"><![CDATA[ES - 地理查询和分析特性]]></title>
        <id>http://xiewxin.github.io/post/es-di-li-cha-xun-he-fen-xi-te-xing/</id>
        <link href="http://xiewxin.github.io/post/es-di-li-cha-xun-he-fen-xi-te-xing/">
        </link>
        <updated>2020-08-15T13:03:50.000Z</updated>
        <content type="html"><![CDATA[<p>相信大家对 <code>elasticsearch</code> (后面简称 <code>ES</code>) ，不管是前端还是后端，甚至是产品的小伙伴都不会陌生。它是时下流行的搜索引擎解决方案，他能干什么呢？</p>
<p>​	1 提供快速的查询</p>
<p>​	2 确保结果的相关性</p>
<p>​	3 非常精确的匹配</p>
<p>​	这一切的一切带来了了强大的搜索效率和精度以及良好的体验，再加上它开源，容易上手，适用性广，社区交流活跃文档齐全等等等等，所以迅速的流行了起来。</p>
<p>​	我们知道 <code>ES</code> 其实适用于许多场景，像大家最常接触的文档存储查询，再比如日志存储和索引等，今天向大家介绍的是 <code>ES</code> 地理数据存储和分析特性，这块大家可能接触的相对没有这么多，本人也是因为行情的实价登录功能的契机才开始用到一些，用了之后觉得体验还是不错的，相信结合大家的才智可以用到更多有意思的地方。</p>
<p>​	在开始之前，先给大家看一下，我们的实价登录长得是这样的，这个模块将社区的行情交易信息，地理信息于 <code>ES</code> 的地理查询和分析特性结合了起来，让用户直观的了解不同地区的房价情况。这是我们使用 <code>ES</code> 的地理特性完成的事情，让大家对他能做什么心里有个数，具体见 https://market.591.com.tw 。下面我们将从 [地理查询] 和 [地理数据聚合] 两个方面向大家介绍 <code>ES</code> 的地理特性。</p>
<figure data-type="image" tabindex="1"><img src="http://xiewxin.github.io//post-images/1597497366768.png" alt="591 实价登录" loading="lazy"></figure>
<h2 id="一-地理查询相关">一、地理查询相关</h2>
<p>​	结合场景也许大家能够更直观的了解，假设大家的数据单位都有地理经纬度信息，在这个前提下我提出下面几个场景</p>
<h3 id="1-地理边界框查询">1. 地理边界框查询</h3>
<p>​	我们想要筛选出地图中某个地理边界框的数据，我们只要使用 <code>ES</code> 的 [地理边界框查询] <code>geo_bounding_box</code> 就可以轻松实现，我们需要做的就是把边界框的左上坐标 <code>top_left</code> 和右下坐标 <code>bottom_right</code> 给到 <code>ES</code> 就可以过滤出该边界框的数据。</p>
<p>语句如下：</p>
<pre><code>GET /market-community/_search
{
    &quot;query&quot;: {
        &quot;bool&quot; : {
            &quot;must&quot; : {
                &quot;match_all&quot; : {}
            },
            &quot;filter&quot; : {
                &quot;geo_bounding_box&quot; : {
                    &quot;search.location&quot; : {
                        &quot;top_left&quot; : {	// 左上坐标
                            &quot;lat&quot; : 25.03635457300217,
                            &quot;lon&quot; : 121.55181610152857
                        },
                        &quot;bottom_right&quot; : {	// 右下坐标
                            &quot;lat&quot; : 25.03413425895166,
                            &quot;lon&quot; : 121.5612842657818
                        }
                    }
                }
            }
        }
    }
}
</code></pre>
<p>然后我们就能得到想要的数据啦~</p>
<figure data-type="image" tabindex="2"><img src="http://xiewxin.github.io//post-images/1597497322151.png" alt="地理边界框查询" loading="lazy"></figure>
<h3 id="2-地理多边形查询">2. 地理多边形查询</h3>
<p>​	我们想要筛选出任意多边形地理边界内的数据，那我们就可以使用 <code>ES</code> 的 [地理多边形查询] <code>geo_polygon</code> ，把我们的绘制的多边形的坐标点按绘制顺序都给到 <code>ES</code> 就可以了，但这里需要注意坐标点一定要按绘制顺序给到 <code>ES</code>，因为 <code>ES</code> 是按顺序将点连接成图形的，否则结果可能就不是我们想要的了~，语句如下：</p>
<pre><code class="language-console">GET /market-community/_search
{
    &quot;query&quot;: {
        &quot;bool&quot; : {
            &quot;must&quot; : {
                &quot;match_all&quot; : {}
            },
            &quot;filter&quot; : {
                &quot;geo_polygon&quot; : {
                    &quot;search.location&quot; : {	// 注意坐标点要按顺序，顺时针逆时针均可
                        &quot;points&quot; : [
                            [121.55823134507727, 25.03582564975867],		
                            [121.55819379415107, 25.035840230943773],
                            [121.5589394482572, 25.035786766589958],
                            [121.55828498925757, 25.035840230943773],
                            ....
                            [121.55826889600348, 25.035840230943773],
                            [121.5582528027494, 25.035835370548934],
                            [121.55824207391333, 25.035835370548934],
                            [121.55823134507727, 25.035835370548934]
                        ]
                    }
                }
            }
        }
    }
}
</code></pre>
<p>结果当然显而易见：</p>
<figure data-type="image" tabindex="3"><img src="http://xiewxin.github.io//post-images/1597497401496.png" alt="地理多边形查询" loading="lazy"></figure>
<h3 id="3-地理距离查询">3. 地理距离查询</h3>
<p>​	我们想要得到坐标点方圆一公里的社区呢？要做的也很简单，只需要使用 [地理距离查询] <code>geo_distance</code> ，比如获取坐标 lat:25.036593627652884, lng:121.5577666374389 方圆100m的的社区。</p>
<p>语句：</p>
<pre><code class="language-console">GET /market-community/_search
{
    &quot;query&quot;: {
        &quot;bool&quot; : {
            &quot;must&quot; : {
                &quot;match_all&quot; : {}
            },
            &quot;filter&quot; : {
                &quot;geo_distance&quot; : {
                    &quot;distance&quot; : &quot;100m&quot;,
                    &quot;search.location&quot; : {
                        &quot;lat&quot; : 25.036593627652884,
                        &quot;lon&quot; : 121.5577666374389
                    }
                }
            }
        }
    }
}
</code></pre>
<p>结果示意：</p>
<figure data-type="image" tabindex="4"><img src="http://xiewxin.github.io//post-images/1597497442041.png" alt="地理距离查询" loading="lazy"></figure>
<p>是不是很简单呢~~只要使用 <code>ES</code> 我们就能轻松完成各种基于地理位置的查询，让我们的数据更具代表性和说服力。</p>
<h2 id="二-地理数据聚合">二、地理数据聚合</h2>
<p>​	地理数据聚合 <code>ES</code> 提供了挺多有意思的聚合查询，[地理边界聚合] 可以为数据集合计算地理边界框，把你的数据框起来；[地理距离聚合] 可以获取坐标点不同范围距离数据区分出来，比如0~1km ，1km~2km。这里只做抛砖引玉的举两个例子。</p>
<h3 id="1-geohash网格聚合">1. GeoHash网格聚合</h3>
<p>​	如果我们想将我们的数据分成若干个地理方块，比如 152.9mx 152.4m ，那我们就可以使用 [GeoHash网格聚合] <code>geohash_grid</code> 的特性，它能帮我们的数据计算出若干个 152.9mx 152.4m 范围的集合。 152.9mx 152.4m 在网格聚合精度级别表里是7（精度后面再说明）。语句如下：</p>
<pre><code class="language-console">POST /market-community/_search?size=0
{
    &quot;aggregations&quot; : {
        &quot;large-grid&quot; : {
            &quot;geohash_grid&quot; : {
                &quot;field&quot; : &quot;search.location&quot;,
                &quot;precision&quot; : 7
            }
        }
    }
}
</code></pre>
<p>返回结果如下：</p>
<pre><code class="language-js">{
    ...
    &quot;aggregations&quot;: {
        &quot;large-grid&quot;: {
            &quot;buckets&quot;: [
                {
                    &quot;key&quot;:&quot;wsqqqn4&quot;,
                    &quot;doc_count&quot;:5,
    			},
    			{
                    &quot;key&quot;:&quot;wsqqqn1&quot;,
                    &quot;doc_count&quot;:5,
    			},
    			{
                    &quot;key&quot;:&quot;wsqqqje&quot;,
                    &quot;doc_count&quot;:5,
    			},
                ...
            ]
        }
    }
}	
</code></pre>
<p>​	这样我们就能比较方便的从数据中知道哪个 152.9mx 152.4m 范围方块里数据最多，延伸的话可以知道平均每个地理方块里有多少数据，或者只根据这个范围进行下一步操作。注意在默认的情况该聚合返回10000条数据，请在使用过程中留意该特性。</p>
<p>​	目前该聚合支持12个精度，虽然它也能自定义，但实际还是根据这12个精度计算数据，所以与其自定义还是老实使用这12个精度吧...精度说明如下。</p>
<table>
<thead>
<tr>
<th><strong>GeoHash长度</strong></th>
<th><strong>区域宽度x高度</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1个</td>
<td>5,009.4公里x 4,992.6公里</td>
</tr>
<tr>
<td>2</td>
<td>1,252.3公里x 624.1公里</td>
</tr>
<tr>
<td>3</td>
<td>156.5公里x 156公里</td>
</tr>
<tr>
<td>4</td>
<td>39.1公里x 19.5公里</td>
</tr>
<tr>
<td>5</td>
<td>4.9公里x 4.9公里</td>
</tr>
<tr>
<td>6</td>
<td>1.2公里x 609.4m</td>
</tr>
<tr>
<td>7</td>
<td>152.9mx 152.4m</td>
</tr>
<tr>
<td>8</td>
<td>38.2mx 19m</td>
</tr>
<tr>
<td>9</td>
<td>4.8mx 4.8m</td>
</tr>
<tr>
<td>10</td>
<td>1.2mx 59.5厘米</td>
</tr>
<tr>
<td>11</td>
<td>14.9厘米x 14.9厘米</td>
</tr>
<tr>
<td>12</td>
<td>3.7厘米x 1.9厘米</td>
</tr>
</tbody>
</table>
<h3 id="2-地心聚集">2. 地心聚集</h3>
<p>​	[地心聚集] <code>geo_centroid</code> 是计算数据集合的加权质心，解决诸如方圆五公里社区最多的点在哪里？大家最喜欢在哪里吃麻辣烫？等问题，他能将你收集的大数据在地理层面有用武之地。在 591实际登陆 功能中就有计算每个 152.9mx 152.4m 地理方块的质心用于地图展示，也算是 [GeoHash网格聚合] 的延伸，语句如下：</p>
<pre><code class="language-console">POST /market-community/_search
{
    &quot;aggs&quot; : {
    	&quot;_point_aggs&quot; : {
    		&quot;geohash_grid&quot; : {
    			&quot;field&quot; : &quot;search.location&quot;,
    			&quot;precision&quot; : 7,
    			&quot;size&quot; : 500,
    		},
    		&quot;aggs&quot; : {
    			&quot;_centroid&quot; : {
                    &quot;geo_centroid&quot; : {
                        &quot;field&quot; : &quot;search.location&quot; 
                    }
       			}
    		}
    	}
    }
}
</code></pre>
<p>返回结果如下</p>
<pre><code>{
    ...
    &quot;aggregations&quot;: {
        &quot;_point_aggs&quot;: {
            &quot;buckets&quot;: [
                {
                    &quot;key&quot;:&quot;wsqqqn4&quot;,
                    &quot;doc_count&quot;:5,
                    &quot;_centroid&quot;:{
                        &quot;location&quot;:{
                            &quot;lat&quot;:25.038318903185427,
                            &quot;lon&quot;:121.55637344531715
                        },
                        &quot;count&quot;:5
                    }
    			},
    			{
                    &quot;key&quot;:&quot;wsqqqn1&quot;,
                    &quot;doc_count&quot;:5,
                    &quot;_centroid&quot;:{
                        &quot;location&quot;:{
                            &quot;lat&quot;:25.03880675509572,
                            &quot;lon&quot;:121.55491943657398
                        },
                        &quot;count&quot;:5
                    }
    			},
    			{
                    &quot;key&quot;:&quot;wsqqqje&quot;,
                    &quot;doc_count&quot;:5,
                    &quot;_centroid&quot;:{
                        &quot;location&quot;:{
                            &quot;lat&quot;:25.035851379856467,
                            &quot;lon&quot;:121.5575652513653
                        },
                        &quot;count&quot;:5
                    }
    			},
                ...
            ]
        }
    }
}		
</code></pre>
<p>我们可以将其展示到地图上：</p>
<figure data-type="image" tabindex="5"><img src="http://xiewxin.github.io//post-images/1597497481109.png" alt="地心聚集" loading="lazy"></figure>
<p>​	<code>ES</code> 的地理特性还有许多，结合不同的场景也有许多的可能性，能让你辛辛苦苦收集大数据不再那么”干“，让数据更直观更有趣更有用，这就是本次分享的内容，希望能给大家带来一点启发和帮助。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ORM]]></title>
        <id>http://xiewxin.github.io/post/eloquent/</id>
        <link href="http://xiewxin.github.io/post/eloquent/">
        </link>
        <updated>2020-08-02T17:25:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="eloquent">Eloquent</h1>
<h3 id="集合">集合</h3>
<p>Eloquent 的 <code>all</code> 和 <code>get</code> 方法可以查询到多个结果，返回一个 <code>Illuminate\Database\Eloquent\Collection</code> 实例。<code>Collection</code> 类提供了 [大量的辅助函数] 来处理 Eloquent 结果：</p>
<pre><code>$flights = $flights-&gt;reject(function ($flight) {
    return $flight-&gt;cancelled;
});
</code></pre>
<p>你可以像数组一样遍历集合：</p>
<pre><code>foreach ($flights as $flight) {
    echo $flight-&gt;name;
}
</code></pre>
<h3 id="分块结果">分块结果</h3>
<p>如果你需要处理数以千计的 Eloquent 结果，使用 <code>chunk</code> 命令。 <code>chunk</code> 方法会检索 Eloquent 模型中的『分块』将他们提供给指定的 <code>Closure</code> 处理。在处理大型结果集时，使用 <code>chunk</code> 方法可以节省内存：</p>
<pre><code>Flight::chunk(200, function ($flights) {
    foreach ($flights as $flight) {
        //
    }
});
</code></pre>
<p>传递到方法的第一个参数是希望每个『分块』接收的数据量。闭包作为第二个参数传递，它在每次从数据库中检索分块的时候调用。它将执行数据库查询把检索分块的结果传递给闭包方法。</p>
<h4 id="使用游标">使用游标</h4>
<p><code>cursor</code> 方法允许你使用游标遍历数据库，它只执行一次查询。处理大量的数据时， <code>cursor</code> 方法可以大大减少内存的使用量：</p>
<pre><code>foreach (Flight::where('foo', 'bar')-&gt;cursor() as $flight) {
    //
}
</code></pre>
<p><code>cursor</code> 返回 <code>Illuminate\Support\LazyCollection</code> 实例。 [Lazy collections] 允许你使用 Laravel 集合中大多数集合方法，而且每次只会加载单个模型到内存中：</p>
<pre><code>$users = App\User::cursor()-&gt;filter(function ($user) {
    return $user-&gt;id &gt; 500;
});

foreach ($users as $user) {
    echo $user-&gt;id;
}
</code></pre>
<h3 id="高级子查询">高级子查询</h3>
<h4 id="selects-子查询">Selects 子查询</h4>
<p>Eloquent 提供了高级子查询支持，你可以用单条查询语句从相关表中提取信息。举个例子，假设我们有一个目的地表 <code>destinations</code> 和一个到目的地的航班表 <code>flights</code>。<code>flights</code> 表包含一个 <code>arrival_at</code> 字段，表示航班何时到达目的地。</p>
<p>使用子查询功能提供的 <code>select</code> 和 <code>addSelect</code> 方法，我们可以用单条语句查询全部目的地 <code>destinations</code>，以及抵达各目的地最后一班飞机的名称：</p>
<pre><code>use App\Destination;
use App\Flight;

return Destination::addSelect(['last_flight' =&gt; Flight::select('name')
    -&gt;whereColumn('destination_id', 'destinations.id')
    -&gt;orderBy('arrived_at', 'desc')
    -&gt;limit(1)
])-&gt;get();
</code></pre>
<h4 id="根据子查询进行排序">根据子查询进行排序</h4>
<p>此外，查询构建器的 <code>orderBy</code> 函数也支持子查询。我们可以使用此功能根据最后一班航班到达目的地的时间对所有目的地排序。 同样，这可以只对数据库执行单个查询：</p>
<pre><code>return Destination::orderByDesc(
    Flight::select('arrived_at')
        -&gt;whereColumn('destination_id', 'destinations.id')
        -&gt;orderBy('arrived_at', 'desc')
        -&gt;limit(1)
)-&gt;get();
</code></pre>
<h2 id="检索单个模型-集合">检索单个模型 / 集合</h2>
<p>除了从指定的数据表检索所有记录外，你可以使用 <code>find</code>、 <code>first</code> 或 <code>firstWhere</code> 方法来检索单条记录。这些方法返回单个模型实例，而不是返回模型集合：</p>
<pre><code>// 通过主键查找一个模型...
$flight = App\Flight::find(1);

// 查找符合查询条件的首个模型...
$flight = App\Flight::where('active', 1)-&gt;first();

// 查找符合查询条件的首个模型的快速实现...
$flight = App\Flight::firstWhere('active', 1);
</code></pre>
<p>你也可以使用主键数组作为参数调用 <code>find</code> 方法，它将返回匹配记录的集合：</p>
<pre><code>$flights = App\Flight::find([1, 2, 3]);
</code></pre>
<p>有时你可能希望在查找首个结果但找不到值时执行其他动作。<code>firstOr</code> 方法将会在查找到结果时返回首个结果，如果没有结果，将会执行给定的回调。回调的返回值将会作为 <code>firstOr</code> 方法的返回值：</p>
<pre><code>$model = App\Flight::where('legs', '&gt;', 100)-&gt;firstOr(function () {
        // ...
});
</code></pre>
<h4 id="检查属性变化">检查属性变化</h4>
<p>Eloquent 提供了 <code>isDirty</code>, <code>isClean</code> 和 <code>wasChanged</code> 方法，以检查模型的内部状态并确定其属性从最初加载时如何变化。</p>
<p><code>isDirty</code> 方法确定自加载模型以来是否已更改任何属性。 您可以传递特定的属性名称来确定特定的属性是否变脏。<code>isClean</code> 方法与 <code>isDirty</code> 相反，它也接受可选的属性参数：</p>
<pre><code>$user = User::create([
    'first_name' =&gt; 'Taylor',
    'last_name' =&gt; 'Otwell',
    'title' =&gt; 'Developer',
]);

$user-&gt;title = 'Painter';

$user-&gt;isDirty(); // true
$user-&gt;isDirty('title'); // true
$user-&gt;isDirty('first_name'); // false

$user-&gt;isClean(); // false
$user-&gt;isClean('title'); // false
$user-&gt;isClean('first_name'); // true

$user-&gt;save();

$user-&gt;isDirty(); // false
$user-&gt;isClean(); // true
</code></pre>
<p><code>wasChanged</code> 方法确定在当前请求周期内最后一次保存模型时是否更改了任何属性。 你还可以传递属性名称以查看特定属性是否已更改：</p>
<pre><code>$user = User::create([
    'first_name' =&gt; 'Taylor',
    'last_name' =&gt; 'Otwell',
    'title' =&gt; 'Developer',
]);

$user-&gt;title = 'Painter';
$user-&gt;save();

$user-&gt;wasChanged(); // true
$user-&gt;wasChanged('title'); // true
$user-&gt;wasChanged('first_name'); // false
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[响应]]></title>
        <id>http://xiewxin.github.io/post/xiang-ying/</id>
        <link href="http://xiewxin.github.io/post/xiang-ying/">
        </link>
        <updated>2020-07-26T13:44:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="创建响应">创建响应</h2>
<h4 id="字符串-数组">字符串 &amp; 数组</h4>
<p>所有路由和控制器处理完业务逻辑之后都会返回一个发送到用户浏览器的响应，Laravel 提供了多种不同的方式来返回响应，最基本的响应就是从路由或控制器返回一个简单的字符串，框架会自动将这个字符串转化为一个完整的 HTTP 响应：</p>
<pre><code>Route::get('/', function () {
    return 'Hello World';
});
</code></pre>
<p>除了从路由或控制器返回字符串之外，还可以返回数组。框架会自动将数组转化为一个 JSON 响应：</p>
<pre><code>Route::get('/', function () {
    return [1, 2, 3];
});
</code></pre>
<h4 id="response-对象">Response 对象</h4>
<p>通常，我们并不只是从路由动作简单返回字符串和数组，大多数情况下，都会返回一个完整的 <code>Illuminate\Http\Response</code> 实例或 视图。</p>
<p>返回完整的 <code>Response</code> 实例允许你自定义响应的 HTTP 状态码和响应头信息。</p>
<p><code>Response</code> 实例 继承自 <code>Symfony\Component\HttpFoundation\Response</code> 类， 该类提供了各种构建 HTTP 响应的方法：</p>
<pre><code>Route::get('home', function () {
    return response('Hello World', 200)
                  -&gt;header('Content-Type', 'text/plain');
});
</code></pre>
<h4 id="添加响应头">添加响应头</h4>
<p>大部分的响应方法都是可链式调用的，使得创建响应实例的过程更具可读性。例如，你可以在响应返回给用户前使用 <code>header</code> 方法为其添加一系列的头信息：</p>
<pre><code>return response($content)
            -&gt;header('Content-Type', $type)
            -&gt;header('X-Header-One', 'Header Value')
            -&gt;header('X-Header-Two', 'Header Value');
</code></pre>
<p>或者，你可以使用 <code>withHeaders</code> 方法来指定要添加到响应的头信息数组：</p>
<h5 id="缓存控制中间件">缓存控制中间件</h5>
<p>Laravel 内置了一个 <code>cache.headers</code> 中间件，可以用来快速地为路由组设置 <code>Cache-Control</code> 头信息。如果在指令集中声明了 <code>etag</code>，Laravel 会自动将 ETag 标识符设置为响应内容的 MD5 哈希值：</p>
<pre><code>Route::middleware('cache.headers:public;max_age=2628000;etag')-&gt;group(function () {
    Route::get('privacy', function () {
        // ...
    });

    Route::get('terms', function () {
        // ...
    });

});
</code></pre>
<h4 id="添加-cookies-到响应">添加 Cookies 到响应</h4>
<p>你可以使用响应上的 <code>cookie</code> 方法轻松地将为响应增加 Cookies。例如，你可以像这样使用 <code>cookie</code> 方法生成一个 cookie 并轻松地将其附加到响应上：</p>
<pre><code>return response($content)
                -&gt;header('Content-Type', $type)
                -&gt;cookie('name', 'value', $minutes);
</code></pre>
<p><code>cookie</code> 方法还接受一些不太频繁使用的参数。通常，这些参数与原生 PHP 的 setcookie方法的参数有着相同的目的和含义：</p>
<pre><code>-&gt;cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly)
</code></pre>
<p>或者，你可以使用 <code>Cookie</code> facade 「队列」， <code>Cookie</code> 以附加到应用程序的传出响应。 <code>queue</code> 方法接受一个 <code>Cookie</code> 实例或创建 <code>Cookie</code> 实例所需的参数。 这些 cookie 在发送到浏览器之前会附加到传出响应中：</p>
<pre><code>Cookie::queue(Cookie::make('name', 'value', $minutes));

Cookie::queue('name', 'value', $minutes);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[請求1]]></title>
        <id>http://xiewxin.github.io/post/qing-qiu-1/</id>
        <link href="http://xiewxin.github.io/post/qing-qiu-1/">
        </link>
        <updated>2020-07-18T08:51:19.000Z</updated>
        <content type="html"><![CDATA[<p>要通过依赖注入获取当前 HTTP 请求实例，你应该在控制器上引入 <code>Illuminate\Http\Request</code> 类。传入的请求实例将会由 服务容器 自动注入：</p>
<pre><code>&lt;?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class UserController extends Controller
{
    /**
     * Store a new user.
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        $name = $request-&gt;input('name');

        //
    }

}
</code></pre>
<h4 id="检索请求路径">检索请求路径</h4>
<p><code>path</code> 方法返回请求的路径信息。因此，如果接收到的请求目标是 <code>http://xiewxin.lv.com/home/request</code>，则 <code>path</code> 方法会返回 <code>home/request</code>：</p>
<pre><code>// 1. path 方法返回请求的路径信息。因此，如果接收到的请求
// 目标是 http://xiewxin.lv.com/home/request，
// 则 path 方法会返回 home/request
$res['path'] = $request-&gt;path();
</code></pre>
<p><code>is</code> 方法验证请求的路径是否与给定的模式匹配。使用此方法时，可以将 <code>*</code> 字符作为通配符：</p>
<pre><code>if ($request-&gt;is('admin/*')) {
    //
}
</code></pre>
<h4 id="获取请求-url">获取请求 URL</h4>
<p>要获取完整的请求 URL，你可以使用 <code>url</code> 或 <code>fullUrl</code> 方法。 <code>url</code> 方法返回不带查询条件的 URL，而 <code>fullUrl</code> 方法的返回包含查询条件字符串。</p>
<pre><code>// 没有包含查询条件字符串
$url = $request-&gt;url();

// 包含查询条件字符串
$url = $request-&gt;fullUrl();
</code></pre>
<h4 id="获取请求方法">获取请求方法</h4>
<p><code>method</code> 方法将会返回请求的 HTTP 动词。 你也可以使用 <code>isMethod</code> 方法去验证 HTTP 动词与所给定的字符串是否匹配</p>
<pre><code>$method = $request-&gt;method();

if ($request-&gt;isMethod('post')) {
    //
}
</code></pre>
<h3 id="psr-7-请求">PSR-7 请求</h3>
<p>PSR-7 标准指定了包括请求与响应在内的 HTTP 的消息接口。如果你想要获取 PSR-7 请求实例而不是 Laravel 请求， 那么你首先需要安装几个库。Laravel 使用 <em>Symfony HTTP Message Bridge</em> 组件将典型的 Laravel 请求和响应转换为 PSR-7 的兼容实现：</p>
<pre><code>composer require symfony/psr-http-message-bridge
composer require nyholm/psr7
</code></pre>
<p>安装这些库后，可以通过路由闭包和控制器方法的请求接口类型提示来获取 PSR-7 请求：</p>
<pre><code>use Psr\Http\Message\ServerRequestInterface;

Route::get('/', function (ServerRequestInterface $request) {
    //
});
</code></pre>
<h2 id="输入过滤-规范化">输入过滤 &amp; 规范化</h2>
<p>默认情况下，Laravel 应用程序的全局中间件堆栈中包含了 <code>TrimStrings</code> 和 <code>ConvertEmptyStringsToNull</code> 中间件。 它们被放在 <code>App\Http\Kernel</code> 类的栈列表中。这些中间件将自动过滤掉请求中的字符串字段，并将空字符串字段转换为 <code>null</code>。 这样一来，你将不用担心路由和控制器的约束规范问题。</p>
<p>如果你想禁用这些行为， 你可以在应用程序中 <code>App\Http\Kernel</code> 类的 <code>$middleware</code> 属性中移除这两个中间件。</p>
<h2 id="获取输入">获取输入</h2>
<p>当处理包含数组的表单时，可以使用 「.」 运算符来访问数组的数据：</p>
<pre><code>$name = $request-&gt;input('products.0.name');

$names = $request-&gt;input('products.*.name');
</code></pre>
<h4 id="从查询字符串获取输入">从查询字符串获取输入</h4>
<p><code>input</code> 方法可以从整个请求体中获取数据（包括查询字符串）, 而 <code>query</code> 方法仅仅从查询字符串中获取输入值：</p>
<pre><code>$name = $request-&gt;query('name');
</code></pre>
<h4 id="通过动态属性获取输入">通过动态属性获取输入</h4>
<p>你也可以通过 <code>Illuminate\Http\Request</code> 接口实例的动态属性访问用户的输入。例如你的一个表单中包含 <code>name</code> 字段，则可以通过下面这种方式获取：</p>
<pre><code>$name = $request-&gt;name;
</code></pre>
<h4 id="获取-json-输入">获取 JSON 输入</h4>
<p>当向应用传递 JSON 请求时，只要将请求头中的 Content-Type 设置为 <code>application/json</code> 后你便可以使用 <code>input</code>方法来获取 JSON 数据。你也可以使用「.」语法获取 JSON 数组内容：</p>
<pre><code>$name = $request-&gt;input('user.name');
</code></pre>
<h4 id="获取部分输入数据">获取部分输入数据</h4>
<p>如果需要获取输入数据的子集，你可以使用 <code>only</code> 或 <code>except</code> 方法。它们接受单个 <code>array</code> 或者动态参数列表：</p>
<pre><code>$input = $request-&gt;only(['username', 'password']);

$input = $request-&gt;only('username', 'password');

$input = $request-&gt;except(['credit_card']);

$input = $request-&gt;except('credit_card');
</code></pre>
<h4 id="判断输入值是否存在">判断输入值是否存在</h4>
<p>你可以使用 <code>has</code> 来判断当前请求中是否含有指定的值。如果请求中存在该值则 <code>has</code> 方法将会返回 <code>true</code>：</p>
<pre><code>if ($request-&gt;has('name')) {
    //
}
</code></pre>
<p>当给定一个数组时，<code>has</code> 将会判断指定的值是否全部存在：</p>
<pre><code>if ($request-&gt;has(['name', 'email'])) {
    //
}
</code></pre>
<p><code>hasAny</code> 方法将会在指定的值有一个存在的情况下返回 <code>true</code>：</p>
<pre><code>if ($request-&gt;hasAny(['name', 'email'])) {
    //
}
</code></pre>
<p>如果你想要判断一个值在请求中是否存在，并且不为空，可以使用 <code>filled</code> 方法：</p>
<pre><code>if ($request-&gt;filled('name')) {
    //
}
</code></pre>
<p>如果你想要判断一个值在请求中是否缺失，可以使用 missing 方法：</p>
<pre><code>if ($request-&gt;missing('name')) {
    //
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合]]></title>
        <id>http://xiewxin.github.io/post/ji-he/</id>
        <link href="http://xiewxin.github.io/post/ji-he/">
        </link>
        <updated>2020-06-21T15:17:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="集合">集合</h1>
<h3 id="扩展集合">扩展集合</h3>
<p>集合都是「可宏扩展」(macroable) 的，它允许你在执行时将其它方法添加到 Collection 类。例如，通过下面的代码在 <code>Collection</code> 类中添加一个 <code>toUpper</code> 方法：</p>
<pre><code>use Illuminate\Support\Collection;
use Illuminate\Support\Str;

Collection::macro('toUpper', function () {
    return $this-&gt;map(function ($value) {
        return Str::upper($value);
    });
});

$collection = collect(['first', 'second']);

$upper = $collection-&gt;toUpper();

// ['FIRST', 'SECOND']
</code></pre>
<p>通常，你应该在 服务提供者 内声明集合宏。</p>
<h2 id="可用方法">可用方法</h2>
<p>我们将讨论每个 <code>Collection</code> 类可用的方法。记住，所有这些方法都可以链式调用以流畅地操作底层数组。此外，几乎所有方法都返回一个新的 <code>Collection</code> 实例，允许你在需要时保存集合的原始副本：</p>
<p>all<br>
average<br>
avg<br>
chunk<br>
collapse<br>
collect<br>
combine<br>
concat<br>
contains<br>
containsStrict<br>
count<br>
countBy<br>
crossJoin<br>
dd<br>
diff<br>
diffAssoc<br>
diffKeys<br>
dump<br>
duplicates<br>
duplicatesStrict<br>
each<br>
eachSpread<br>
every<br>
except<br>
filter<br>
first<br>
firstWhere<br>
flatMap<br>
flatten<br>
flip<br>
forget<br>
forPage<br>
get<br>
groupBy<br>
has<br>
implode<br>
intersect<br>
intersectByKeys<br>
isEmpty<br>
isNotEmpty<br>
join<br>
keyBy<br>
keys<br>
last<br>
macro<br>
make<br>
map<br>
mapInto<br>
mapSpread<br>
mapToGroups<br>
mapWithKeys<br>
max<br>
median<br>
merge<br>
mergeRecursive<br>
min<br>
mode<br>
nth<br>
only<br>
pad<br>
partition<br>
pipe<br>
pluck<br>
pop<br>
prepend<br>
pull<br>
push<br>
put<br>
random<br>
reduce<br>
reject<br>
replace<br>
replaceRecursive<br>
reverse<br>
search<br>
shift<br>
shuffle<br>
skip<br>
slice<br>
some<br>
sort<br>
sortBy<br>
sortByDesc<br>
sortDesc<br>
sortKeys<br>
sortKeysDesc<br>
splice<br>
split<br>
sum<br>
take<br>
tap<br>
times<br>
toArray<br>
toJson<br>
transform<br>
union<br>
unique<br>
uniqueStrict<br>
unless<br>
unlessEmpty<br>
unlessNotEmpty<br>
unwrap<br>
values<br>
when<br>
whenEmpty<br>
whenNotEmpty<br>
where<br>
whereStrict<br>
whereBetween<br>
whereIn<br>
whereInStrict<br>
whereInstanceOf<br>
whereNotBetween<br>
whereNotIn<br>
whereNotInStrict<br>
whereNotNull<br>
whereNull<br>
wrap<br>
zip</p>
<h2 id="方法列表">方法列表</h2>
<h4 id="all"><code>all()</code></h4>
<p><code>all</code> 方法返回代表集合的底层数组：</p>
<pre><code>collect([1, 2, 3])-&gt;all();

// [1, 2, 3]
</code></pre>
<h4 id="average"><code>average()</code></h4>
<p><code>avg</code> 方法的别名。</p>
<h4 id="avg"><code>avg()</code></h4>
<p><code>avg</code> 方法返回指定键的 平均值：</p>
<pre><code>$average = collect([['foo' =&gt; 10], ['foo' =&gt; 10], ['foo' =&gt; 20], ['foo' =&gt; 40]])-&gt;avg('foo');

// 20

$average = collect([1, 1, 2, 4])-&gt;avg();

// 2
</code></pre>
<h4 id="chunk"><code>chunk()</code></h4>
<p><code>chunk</code> 方法把集合分割成多个指定大小的较小集合：</p>
<pre><code>$collection = collect([1, 2, 3, 4, 5, 6, 7]);

$chunks = $collection-&gt;chunk(4);

$chunks-&gt;toArray();

// [[1, 2, 3, 4], [5, 6, 7]]
</code></pre>
<p>当使用如 Bootstrap 那样的栅格系统时，该方法在 视图 中相当有用。想象一下你有个想在栅格显示的Eloquent 模型：</p>
<pre><code>@foreach ($products-&gt;chunk(3) as $chunk)
    &lt;div class=&quot;row&quot;&gt;
        @foreach ($chunk as $product)
            &lt;div class=&quot;col-xs-4&quot;&gt;{{ $product-&gt;name }}&lt;/div&gt;
        @endforeach
    &lt;/div&gt;
@endforeach
</code></pre>
<h4 id="collapse"><code>collapse()</code></h4>
<p><code>collapse</code> 方法把一个多数组集合坍缩为单个扁平的集合：</p>
<pre><code>$collection = collect([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);

$collapsed = $collection-&gt;collapse();

$collapsed-&gt;all();

// [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<h4 id="combine"><code>combine()</code></h4>
<p><code>combine</code> 方法将一个集合的值作为键，与另一个数组或集合的值进行结合：</p>
<pre><code>$collection = collect(['name', 'age']);

$combined = $collection-&gt;combine(['George', 29]);

$combined-&gt;all();

// ['name' =&gt; 'George', 'age' =&gt; 29]
</code></pre>
<h4 id="collect"><code>collect()</code></h4>
<p><code>collect</code> 方法返回一个包含当前集合所含元素的新 <code>Collection</code> 实例：</p>
<pre><code>$collectionA = collect([1, 2, 3]);

$collectionB = $collectionA-&gt;collect();

$collectionB-&gt;all();

// [1, 2, 3]
</code></pre>
<p><code>collect</code> 方法从根本上对将 懒集合 转换为标准 <code>Collection</code> 实例有用:</p>
<pre><code>$lazyCollection = LazyCollection::make(function () {
    yield 1;
    yield 2;
    yield 3;
});

$collection = $lazyCollection-&gt;collect();

get_class($collection);

// 'Illuminate\Support\Collection'

$collection-&gt;all();

// [1, 2, 3]
</code></pre>
<h4 id="concat"><code>concat()</code></h4>
<p><code>concat</code> 方法在集合的末端附加指定的 <code>数组</code> 或集合值：</p>
<pre><code>$collection = collect(['John Doe']);

$concatenated = $collection-&gt;concat(['Jane Doe'])-&gt;concat(['name' =&gt; 'Johnny Doe']);

$concatenated-&gt;all();

// ['John Doe', 'Jane Doe', 'Johnny Doe']
</code></pre>
<h4 id="contains"><code>contains()</code></h4>
<p><code>contains</code> 方法检查集合有否包含指定的元素：</p>
<pre><code>$collection = collect(['name' =&gt; 'Desk', 'price' =&gt; 100]);

$collection-&gt;contains('Desk');

// true

$collection-&gt;contains('New York');

// false
</code></pre>
<p>你也可以传递一个键 / 值对给 <code>contains</code> 方法，它将检查集合有否存在指定的键 / 值对：</p>
<pre><code>$collection = collect([
    ['product' =&gt; 'Desk', 'price' =&gt; 200],
    ['product' =&gt; 'Chair', 'price' =&gt; 100],
]);

$collection-&gt;contains('product', 'Bookcase');

// false
</code></pre>
<p>最后，你也可以传递一个回调函数给 <code>contains</code> 方法去执行你的真值检验：</p>
<pre><code>$collection = collect([1, 2, 3, 4, 5]);

$collection-&gt;contains(function ($value, $key) {
    return $value &gt; 5;
});

// false
</code></pre>
<p><code>contains</code> 方法用 “松散” 比较检查元素值，意味着整数值的字符串会被视同等值的整数。用 <code>containsStrict</code> 方法使用 “严格” 比较过滤。</p>
<h4 id="containsstrict"><code>containsStrict()</code></h4>
<p>这个方法和 <code>contains</code> 方法类似；但是它却是使用了「严格」比较来比较所有的值。</p>
<h4 id="count"><code>count()</code></h4>
<p><code>count</code> 方法返回这个集合内集合项的总数量：</p>
<pre><code>$collection = collect([1, 2, 3, 4]);

$collection-&gt;count();

// 4
</code></pre>
<h4 id="countby"><code>countBy()</code></h4>
<p><code>countBy</code> 方法计算集合中每个值的出现次数。默认情况下，该方法计算每个元素的出现次数：</p>
<pre><code>$collection = collect([1, 2, 2, 2, 3]);

$counted = $collection-&gt;countBy();

$counted-&gt;all();

// [1 =&gt; 1, 2 =&gt; 3, 3 =&gt; 1]
</code></pre>
<p>但是，你也可以向 <code>countBy</code> 传递一个回调函数来计算自定义的值出现的次数:</p>
<pre><code>$collection = collect(['alice@gmail.com', 'bob@yahoo.com', 'carlos@gmail.com']);

$counted = $collection-&gt;countBy(function ($email) {
    return substr(strrchr($email, &quot;@&quot;), 1);
});

$counted-&gt;all();

// ['gmail.com' =&gt; 2, 'yahoo.com' =&gt; 1]
</code></pre>
<h4 id="crossjoin"><code>crossJoin()</code></h4>
<p><code>crossJoin</code> 方法交叉连接指定数组或集合的值，返回所有可能排列的笛卡尔积:</p>
<pre><code>$collection = collect([1, 2]);

$matrix = $collection-&gt;crossJoin(['a', 'b']);

$matrix-&gt;all();

/*
    [
        [1, 'a'],
        [1, 'b'],
        [2, 'a'],
        [2, 'b'],
    ]
*/

$collection = collect([1, 2]);

$matrix = $collection-&gt;crossJoin(['a', 'b'], ['I', 'II']);

$matrix-&gt;all();

/*
    [
        [1, 'a', 'I'],
        [1, 'a', 'II'],
        [1, 'b', 'I'],
        [1, 'b', 'II'],
        [2, 'a', 'I'],
        [2, 'a', 'II'],
        [2, 'b', 'I'],
        [2, 'b', 'II'],
    ]
*/
</code></pre>
<h4 id="dd"><code>dd()</code></h4>
<p><code>dd</code> 方法用于打印集合元素并中断脚本执行：</p>
<pre><code>$collection = collect(['John Doe', 'Jane Doe']);

$collection-&gt;dd();

/*
    Collection {
        #items: array:2 [
            0 =&gt; &quot;John Doe&quot;
            1 =&gt; &quot;Jane Doe&quot;
        ]
    }
*/
</code></pre>
<p>如果你不想中断执行脚本，请使用 <code>dump</code> 方法替代。</p>
<h4 id="diff"><code>diff()</code></h4>
<p><code>diff</code> 方法将集合与其它集合或者 PHP 数组进行值的比较。然后返回原集合中存在而指定集合中不存在的值：</p>
<pre><code>$collection = collect([1, 2, 3, 4, 5]);

$diff = $collection-&gt;diff([2, 4, 6, 8]);

$diff-&gt;all();

// [1, 3, 5]
</code></pre>
<h4 id="diffassoc"><code>diffAssoc()</code></h4>
<p><code>diffAssoc</code> 方法与另外一个集合或基于 PHP 数组的键 / 值对（<code>keys and values</code>）进行比较。这个方法将会返回原集合不存在于指定集合的键 / 值对：</p>
<pre><code>$collection = collect([
    'color' =&gt; 'orange',
    'type' =&gt; 'fruit',
    'remain' =&gt; 6
]);

$diff = $collection-&gt;diffAssoc([
    'color' =&gt; 'yellow',
    'type' =&gt; 'fruit',
    'remain' =&gt; 3,
    'used' =&gt; 6,
]);

$diff-&gt;all();

// ['color' =&gt; 'orange', 'remain' =&gt; 6]
</code></pre>
<h4 id="diffkeys"><code>diffKeys()</code></h4>
<p><code>diffKeys</code> 方法和另外一个集合或 PHP 数组的键（<code>keys</code>）进行比较，然后返回原集合中存在而指定集合中不存在键所对应的键 / 值对：</p>
<pre><code>$collection = collect([
    'one' =&gt; 10,
    'two' =&gt; 20,
    'three' =&gt; 30,
    'four' =&gt; 40,
    'five' =&gt; 50,
]);

$diff = $collection-&gt;diffKeys([
    'two' =&gt; 2,
    'four' =&gt; 4,
    'six' =&gt; 6,
    'eight' =&gt; 8,
]);

$diff-&gt;all();

// ['one' =&gt; 10, 'three' =&gt; 30, 'five' =&gt; 50]
</code></pre>
<h4 id="dump"><code>dump()</code></h4>
<p><code>dump</code> 方法用于打印集合项：</p>
<pre><code>$collection = collect(['John Doe', 'Jane Doe']);

$collection-&gt;dump();

/*
    Collection {
        #items: array:2 [
            0 =&gt; &quot;John Doe&quot;
            1 =&gt; &quot;Jane Doe&quot;
        ]
    }
*/
</code></pre>
<p>如果要在打印集合后终止执行脚本，请使用 <code>dd</code> 方法代替。</p>
<h4 id="duplicates"><code>duplicates()</code></h4>
<p><code>duplicates</code> 方法从集合中检索并返回重复的值：</p>
<pre><code>$collection = collect(['a', 'b', 'a', 'c', 'b']);

$collection-&gt;duplicates();

// [2 =&gt; 'a', 4 =&gt; 'b']
</code></pre>
<p>如果集合包含数组或对象，则可以传递希望检查重复值的属性的键：</p>
<pre><code>$employees = collect([
    ['email' =&gt; 'abigail@example.com', 'position' =&gt; 'Developer'],
    ['email' =&gt; 'james@example.com', 'position' =&gt; 'Designer'],
    ['email' =&gt; 'victoria@example.com', 'position' =&gt; 'Developer'],
])

$employees-&gt;duplicates('position');

// [2 =&gt; 'Developer']
</code></pre>
<h4 id="duplicatesstrict"><code>duplicatesStrict()</code></h4>
<p>此方法与 <code>duplicates</code> 方法具有相同的签名；但是，所有值都以「严格」的方式进行比较。</p>
<h4 id="each"><code>each()</code></h4>
<p><code>each</code> 方法用于循环集合项并将其传递到回调函数中：</p>
<pre><code>$collection-&gt;each(function ($item, $key) {
    //
});
</code></pre>
<p>如果你想中断对集合项的循环，那么就在你的回调函数中返回 <code>false</code> ：</p>
<pre><code>$collection-&gt;each(function ($item, $key) {
    if (/* some condition */) {
        return false;
    }
});
</code></pre>
<h4 id="eachspread"><code>eachSpread()</code></h4>
<p><code>eachSpread</code> 方法用于循环集合项，将每个嵌套集合项的值传递给回调函数：</p>
<pre><code>$collection = collect([['John Doe', 35], ['Jane Doe', 33]]);

$collection-&gt;eachSpread(function ($name, $age) {
    //
});
</code></pre>
<p>你可以通过在回调函数里返回 <code>false</code> 来中断循环：</p>
<pre><code>$collection-&gt;eachSpread(function ($name, $age) {
    return false;
});
</code></pre>
<h4 id="every"><code>every()</code></h4>
<p><code>every</code> 方法可用于验证集合中的每一个元素是否通过指定的条件测试：</p>
<pre><code>collect([1, 2, 3, 4])-&gt;every(function ($value, $key) {
    return $value &gt; 2;
});

// false
</code></pre>
<p>如果集合为空， <code>every</code> 将返回 true ：<br>
$collection = collect([]);</p>
<pre><code>$collection-&gt;every(function ($value, $key) {
    return $value &gt; 2;
});

// true
</code></pre>
<h4 id="except"><code>except()</code></h4>
<p><code>except</code> 方法返回集合中除了指定键之外的所有集合项：</p>
<pre><code>$collection = collect(['product_id' =&gt; 1, 'price' =&gt; 100, 'discount' =&gt; false]);

$filtered = $collection-&gt;except(['price', 'discount']);

$filtered-&gt;all();

// ['product_id' =&gt; 1]
</code></pre>
<p>与 <code>except</code> 对应的是 only 方法。</p>
<h4 id="filter"><code>filter()</code></h4>
<p><code>filter</code> 方法使用给定的回调函数过滤集合，只保留那些通过指定条件测试的集合项：</p>
<pre><code>$collection = collect([1, 2, 3, 4]);

$filtered = $collection-&gt;filter(function ($value, $key) {
    return $value &gt; 2;
});

$filtered-&gt;all();

// [3, 4]
</code></pre>
<p>如果没有提供回调函数，集合中所有返回 <code>false</code> 的元素都会被移除：</p>
<pre><code>$collection = collect([1, 2, 3, null, false, '', 0, []]);

$collection-&gt;filter()-&gt;all();

// [1, 2, 3]
</code></pre>
<p><code>filter</code> 对应的是 reject 方法。</p>
<h4 id="first"><code>first()</code></h4>
<p><code>first</code> 方法返回集合中通过指定条件测试的第一个元素：</p>
<pre><code>collect([1, 2, 3, 4])-&gt;first(function ($value, $key) {
    return $value &gt; 2;
});

// 3
</code></pre>
<p>你也可以不传入参数调用 <code>first</code> 方法来获取集合中的第一个元素。如果集合为空，则会返回 <code>null</code> ：</p>
<pre><code>collect([1, 2, 3, 4])-&gt;first();

// 1
</code></pre>
<h4 id="firstwhere"><code>firstWhere()</code></h4>
<p><code>firstWhere</code> 方法返回集合中含有指定键 / 值对的第一个元素：</p>
<pre><code>$collection = collect([
    ['name' =&gt; 'Regena', 'age' =&gt; null],
    ['name' =&gt; 'Linda', 'age' =&gt; 14],
    ['name' =&gt; 'Diego', 'age' =&gt; 23],
    ['name' =&gt; 'Linda', 'age' =&gt; 84],
]);

$collection-&gt;firstWhere('name', 'Linda');

// ['name' =&gt; 'Linda', 'age' =&gt; 14]
</code></pre>
<p>你也可以使用运算符来调用 <code>firstWhere</code> 方法：</p>
<pre><code>$collection-&gt;firstWhere('age', '&gt;=', 18);

// ['name' =&gt; 'Diego', 'age' =&gt; 23]
</code></pre>
<p>和 <code>where</code> 方法一样，你可以将一个参数传递给 <code>firstWhere</code> 方法。在这种情况下， <code>firstWhere</code> 方法将返回指定键的值为「真」的第一个集合项：</p>
<pre><code>$collection-&gt;firstWhere('age');

// ['name' =&gt; 'Linda', 'age' =&gt; 14]
</code></pre>
<h4 id="flatmap"><code>flatMap()</code></h4>
<p><code>flatMap</code> 方法遍历集合并将其中的每个值传递到给定的回调函数。可以通过回调函数修改集合项并返回它们，从而形成一个被修改过的新集合。然后，集合转化的数组是同级的：</p>
<pre><code>$collection = collect([
    ['name' =&gt; 'Sally'],
    ['school' =&gt; 'Arkansas'],
    ['age' =&gt; 28]
]);

$flattened = $collection-&gt;flatMap(function ($values) {
    return array_map('strtoupper', $values);
});

$flattened-&gt;all();

// ['name' =&gt; 'SALLY', 'school' =&gt; 'ARKANSAS', 'age' =&gt; '28'];
</code></pre>
<h4 id="flip"><code>flip()</code></h4>
<p><code>flip</code> 方法将集合的键和对应的值进行互换：</p>
<pre><code>$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);

$flipped = $collection-&gt;flip();

$flipped-&gt;all();

// ['taylor' =&gt; 'name', 'laravel' =&gt; 'framework']
</code></pre>
<h4 id="forget"><code>forget()</code></h4>
<p><code>forget</code> 方法将通过指定的键来移除集合中对应的内容：</p>
<pre><code>$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);

$collection-&gt;forget('name');

$collection-&gt;all();

// ['framework' =&gt; 'laravel']
</code></pre>
<p>注意：与大多数集合的方法不同的是， <code>forget</code> 不会返回修改后的新集合；它会直接修改原集合。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[辅助函数]]></title>
        <id>http://xiewxin.github.io/post/fu-zhu-han-shu/</id>
        <link href="http://xiewxin.github.io/post/fu-zhu-han-shu/">
        </link>
        <updated>2020-06-07T09:10:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="辅助函数">辅助函数</h1>
<h2 id="可用方法">可用方法</h2>
<h3 id="数组对象">数组&amp;对象</h3>
<p>Arr::add<br>
Arr::collapse<br>
Arr::crossJoin<br>
Arr::divide<br>
Arr::dot<br>
Arr::except<br>
Arr::first<br>
Arr::flatten<br>
Arr::forget<br>
Arr::get<br>
Arr::has<br>
Arr::isAssoc<br>
Arr::last<br>
Arr::only<br>
Arr::pluck<br>
Arr::prepend<br>
Arr::pull<br>
Arr::random<br>
Arr::query<br>
Arr::set<br>
Arr::shuffle<br>
Arr::sort<br>
Arr::sortRecursive<br>
Arr::where<br>
Arr::wrap<br>
data_fill<br>
data_get<br>
data_set<br>
head<br>
last</p>
<h3 id="路徑">路徑</h3>
<p>app_path<br>
base_path<br>
config_path<br>
database_path<br>
mix<br>
public_path</p>
<p>resource_path</p>
<p>storage_path</p>
<h3 id="字符串">字符串</h3>
<p>__</p>
<p>class_basename<br>
e<br>
preg_replace_array<br>
Str::after<br>
Str::afterLast<br>
Str::before<br>
Str::beforeLast<br>
Str::camel<br>
Str::contains<br>
Str::containsAll<br>
Str::endsWith<br>
Str::finish<br>
Str::is<br>
Str::isUuid<br>
Str::kebab<br>
Str::limit<br>
Str::orderedUuid<br>
Str::plural<br>
Str::random<br>
Str::replaceArray<br>
Str::replaceFirst<br>
Str::replaceLast<br>
Str::singular</p>
<p>Str::slug<br>
Str::snake<br>
Str::start<br>
Str::startsWith<br>
Str::studly<br>
Str::title<br>
Str::ucfirst<br>
Str::uuid<br>
Str::words<br>
trans<br>
trans_choice</p>
<h2 id="方法列表">方法列表</h2>
<h3 id="数组对象-2">数组&amp;对象</h3>
<h4 id="arradd-collection-method-first-collection-method"><code>Arr::add()</code> {#collection-method .first-collection-method}</h4>
<p>如果给定的键在数组中不存在或数组被设置为 <code>null</code> ，那么 <code>Arr::add</code> 函数将会把给定的键值对添加到数组中：</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::add(['name' =&gt; 'Desk'], 'price', 100);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]

$array = Arr::add(['name' =&gt; 'Desk', 'price' =&gt; null], 'price', 100);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<h4 id="arrcollapse-collection-method"><code>Arr::collapse()</code> {#collection-method}</h4>
<p><code>Arr::collapse</code> 函数将多个数组合并为一个数组:</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);

// [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<h4 id="arrcrossjoin-collection-method">Arr::crossJoin() {#collection-method}</h4>
<p><code>Arr :: crossJoin</code> 函数交叉连接给定的数组，返回具有所有可能排列的笛卡尔乘积：</p>
<pre><code>use Illuminate\Support\Arr;

$matrix = Arr::crossJoin([1, 2], ['a', 'b']);

/*
    [
        [1, 'a'],
        [1, 'b'],
        [2, 'a'],
        [2, 'b'],
    ]
*/

$matrix = Arr::crossJoin([1, 2], ['a', 'b'], ['I', 'II']);

/*
    [
        [1, 'a', 'I'],
        [1, 'a', 'II'],
        [1, 'b', 'I'],
        [1, 'b', 'II'],
        [2, 'a', 'I'],
        [2, 'a', 'II'],
        [2, 'b', 'I'],
        [2, 'b', 'II'],
    ]
*/
</code></pre>
<h4 id="arrdivide-collection-method"><code>Arr::divide()</code> {#collection-method}</h4>
<p><code>Arr::divide</code> 函数返回一个二维数组，一个值包含原始数组的键，另一个值包含原始数组的值</p>
<pre><code>use Illuminate\Support\Arr;

[$keys, $values] = Arr::divide(['name' =&gt; 'Desk']);

// $keys: ['name']

// $values: ['Desk']
</code></pre>
<h4 id="arrdot-collection-method">Arr::dot() {#collection-method}</h4>
<p><code>Arr::dot</code> 函数将多维数组中所有的键平铺到一维数组中，新数组使用「.」符号表示层级包含关系：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$flattened = Arr::dot($array);

// ['products.desk.price' =&gt; 100]
</code></pre>
<h4 id="arrexcept-collection-method">Arr::except() {#collection-method}</h4>
<p><code>Arr::except</code> 函数从数组中删除指定的键值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100];

$filtered = Arr::except($array, ['price']);

// ['name' =&gt; 'Desk']
</code></pre>
<h4 id="arrfirst-collection-method">Arr::first() {#collection-method}</h4>
<p><code>Arr::first</code> 函数返回数组中通过真值测试的第一个元素：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, 200, 300];

$first = Arr::first($array, function ($value, $key) {
    return $value &gt;= 150;
});

// 200
</code></pre>
<p>将默认值作为第三个参数传递给该方法， 如果数组中没有值通过真值测试，则返回默认值：</p>
<pre><code>use Illuminate\Support\Arr;

$first = Arr::first($array, $callback, $default);
</code></pre>
<h4 id="arrflatten-collection-method">Arr::flatten() {#collection-method}</h4>
<p><code>Arr::flatten</code> 函数将多维数组中数组的值取出平铺为一维数组：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Joe', 'languages' =&gt; ['PHP', 'Ruby']];

$flattened = Arr::flatten($array);

// ['Joe', 'PHP', 'Ruby']
</code></pre>
<h4 id="arrforget-collection-method">Arr::forget() {#collection-method}</h4>
<p><code>Arr::forget</code> 函数使用「.」符号从深度嵌套的数组中删除给定的键值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

Arr::forget($array, 'products.desk');

// ['products' =&gt; []]
</code></pre>
<h4 id="arrget-collection-method">Arr::get() {#collection-method}</h4>
<p><code>Arr::get</code> 函数使用「.」符号从深度嵌套的数组中根据指定键检索值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$price = Arr::get($array, 'products.desk.price');

// 100
</code></pre>
<p><code>Arr::get</code> 函数也接受一个默认值，如果没有找到特定的键，将返回默认值：</p>
<pre><code>use Illuminate\Support\Arr;

$discount = Arr::get($array, 'products.desk.discount', 0);

// 0
</code></pre>
<h4 id="arrhas-collection-method">Arr::has() {#collection-method}</h4>
<p><code>Arr::has</code> 函数使用「.」符号查找数组中是否存在指定的一个或多个键：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]];

$contains = Arr::has($array, 'product.name');

// true

$contains = Arr::has($array, ['product.price', 'product.discount']);

// false
</code></pre>
<h4 id="arrisassoc-collection-method">Arr::isAssoc() {#collection-method}</h4>
<p>如果给定数组是关联数组，则 <code>Arr::isAssoc</code> 函数返回 <code>true</code> 。如果数组没有以零开头的连续数字键，则将其视为 “关联”。</p>
<pre><code>use Illuminate\Support\Arr;

$isAssoc = Arr::isAssoc(['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]]);

// true

$isAssoc = Arr::isAssoc([1, 2, 3]);

// false
</code></pre>
<h4 id="arrlast-collection-method">Arr::last() {#collection-method}</h4>
<p><code>Arr::last</code> 函数返回数组中满足指定条件的最后一个元素：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, 200, 300, 110];

$last = Arr::last($array, function ($value, $key) {
    return $value &gt;= 150;
});

// 300
</code></pre>
<p>将默认值作为第三个参数传递给该方法，如果没有值通过真值测试，则返回该默认值：</p>
<pre><code>use Illuminate\Support\Arr;

$last = Arr::last($array, $callback, $default);
</code></pre>
<h4 id="arronly-collection-method">Arr::only() {#collection-method}</h4>
<p><code>Arr::only</code> 函数只返回给定数组中指定的键值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100, 'orders' =&gt; 10];

$slice = Arr::only($array, ['name', 'price']);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<h4 id="arrpluck-collection-method">Arr::pluck() {#collection-method}</h4>
<p><code>Arr::pluck</code> 函数从数组中检索给定键的所有值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['developer' =&gt; ['id' =&gt; 1, 'name' =&gt; 'Taylor']],
    ['developer' =&gt; ['id' =&gt; 2, 'name' =&gt; 'Abigail']],
];

$names = Arr::pluck($array, 'developer.name');

// ['Taylor', 'Abigail']
</code></pre>
<p>你也可以指定获取的结果的键：</p>
<pre><code>use Illuminate\Support\Arr;

$names = Arr::pluck($array, 'developer.name', 'developer.id');

// [1 =&gt; 'Taylor', 2 =&gt; 'Abigail']
</code></pre>
<h4 id="arrprepend-collection-method">Arr::prepend() {#collection-method}</h4>
<p><code>Arr::prepend</code> 函数将一个值插入到数组的开始位置：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['one', 'two', 'three', 'four'];

$array = Arr::prepend($array, 'zero');

// ['zero', 'one', 'two', 'three', 'four']
</code></pre>
<p>如果需要，你可以指定你插入值的键：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['price' =&gt; 100];

$array = Arr::prepend($array, 'Desk', 'name');

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<h4 id="arrpull-collection-method">Arr::pull() {#collection-method}</h4>
<p><code>Arr::pull</code> 函数从数组中返回指定键的值并删除此键／值对：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100];

$name = Arr::pull($array, 'name');

// $name: Desk

// $array: ['price' =&gt; 100]
</code></pre>
<p>默认值可以作为第三个参数传递给该方法，如果键不存在，则返回该值：</p>
<pre><code>use Illuminate\Support\Arr;

$value = Arr::pull($array, $key, $default);
</code></pre>
<h4 id="arrrandom-collection-method">Arr::random() {#collection-method}</h4>
<p><code>Arr::random</code> 函数从数组中随机返回一个值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [1, 2, 3, 4, 5];

$random = Arr::random($array);

// 4 - (retrieved randomly)
</code></pre>
<p>你也可以将返回值的数量作为可选的第二个参数传递给该方法，请注意，提供这个参数会返回一个数组，即使是你只需要一项：</p>
<pre><code>use Illuminate\Support\Arr;

$items = Arr::random($array, 2);

// [2, 5] - (retrieved randomly)
</code></pre>
<h4 id="arrquery-collection-method">Arr::query() {#collection-method}</h4>
<p><code>Arr::query</code> 函数将数组转换为查询字符串：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Taylor', 'order' =&gt; ['column' =&gt; 'created_at', 'direction' =&gt; 'desc']];

Arr::query($array);

// name=Taylor&amp;order[column]=created_at&amp;order[direction]=desc
</code></pre>
<h4 id="arrset-collection-method">Arr::set() {#collection-method}</h4>
<p><code>Arr::set</code> 函数使用「.」符号在多维数组中设置指定键的值：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

Arr::set($array, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 200]]]
</code></pre>
<h4 id="arrshuffle-collection-method">Arr::shuffle() {#collection-method}</h4>
<p><code>Arr::shuffle</code> 函数将数组中值进行随机排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::shuffle([1, 2, 3, 4, 5]);

// [3, 2, 5, 1, 4] - (generated randomly)
</code></pre>
<h4 id="arrsort-collection-method">Arr::sort() {#collection-method}</h4>
<p><code>Arr::sort</code> 函数根据数组的值对数组进行排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['Desk', 'Table', 'Chair'];

$sorted = Arr::sort($array);

// ['Chair', 'Desk', 'Table']
</code></pre>
<p>你也可以根据给定闭包返回的结果对数组进行排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['name' =&gt; 'Desk'],
    ['name' =&gt; 'Table'],
    ['name' =&gt; 'Chair'],
];

$sorted = array_values(Arr::sort($array, function ($value) {
    return $value['name'];
}));

/*
    [
        ['name' =&gt; 'Chair'],
        ['name' =&gt; 'Desk'],
        ['name' =&gt; 'Table'],
    ]
*/
</code></pre>
<h4 id="arrsortrecursive-collection-method">Arr::sortRecursive() {#collection-method}</h4>
<p><code>Arr::sortRecursive</code> 函数使用 <code>sort</code> 函数对数值子数组进行递归排序，使用 <code>ksort</code> 函数对关联子数组进行递归排序：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['Roman', 'Taylor', 'Li'],
    ['PHP', 'Ruby', 'JavaScript'],
    ['one' =&gt; 1, 'two' =&gt; 2, 'three' =&gt; 3],
];

$sorted = Arr::sortRecursive($array);

/*
    [
        ['JavaScript', 'PHP', 'Ruby'],
        ['one' =&gt; 1, 'three' =&gt; 3, 'two' =&gt; 2],
        ['Li', 'Roman', 'Taylor'],
    ]
*/
</code></pre>
<h4 id="arrwhere-collection-method">Arr::where() {#collection-method}</h4>
<p><code>Arr::where</code> 函数使用给定闭包返回的结果过滤数组：</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, '200', 300, '400', 500];

$filtered = Arr::where($array, function ($value, $key) {
    return is_string($value);
});

// [1 =&gt; '200', 3 =&gt; '400']
</code></pre>
<h4 id="arrwrap-collection-method">Arr::wrap() {#collection-method}</h4>
<p><code>Arr::wrap</code> 方法可以将给定值转换为一个数组。如果给定值已经是一个数组，将不会进行转换：</p>
<pre><code>use Illuminate\Support\Arr;

$string = 'Laravel';

$array = Arr::wrap($string);

// ['Laravel']
</code></pre>
<p>如果给定值是 <code>null</code> ，将返回一个空数组：</p>
<pre><code>use Illuminate\Support\Arr;

$nothing = null;

$array = Arr::wrap($nothing);

// []
</code></pre>
<h4 id="data_fill-collection-method">data_fill() {#collection-method}</h4>
<p><code>data_fill</code> 函数以 . 形式给嵌套数组或对象中设置缺省值：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_fill($data, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]]

data_fill($data, 'products.desk.discount', 10);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100, 'discount' =&gt; 10]]]
</code></pre>
<p>这个函数也可以接收一个 <code>*</code> 作为通配符，并对相应位置进行填充：</p>
<pre><code>$data = [
    'products' =&gt; [
        ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
        ['name' =&gt; 'Desk 2'],
    ],
];

data_fill($data, 'products.*.price', 200);

/*
    [
        'products' =&gt; [
            ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
            ['name' =&gt; 'Desk 2', 'price' =&gt; 200],
        ],
    ]
*/
</code></pre>
<h4 id="data_get-collection-method">data_get() {#collection-method}</h4>
<p><code>data_get</code> 函数可使用 . 形式获得嵌套函数或者对象中的值：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$price = data_get($data, 'products.desk.price');

// 100
</code></pre>
<p>当找不到指定键名时，<code>data_get</code> 函数也支持返回一个默认值：</p>
<pre><code>$discount = data_get($data, 'products.desk.discount', 0);

// 0
</code></pre>
<p>这个函数也可以接受一个 <code>*</code> 作为通配符，以匹配数组或对象中任意键名：</p>
<pre><code>$data = [
    'product-one' =&gt; ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
    'product-two' =&gt; ['name' =&gt; 'Desk 2', 'price' =&gt; 150],
];

data_get($data, '*.name');

// ['Desk 1', 'Desk 2'];
</code></pre>
<h4 id="data_set-collection-method">data_set() {#collection-method}</h4>
<p><code>data_set</code> 函数可以用 . 形式给嵌套函数或对象赋值：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_set($data, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 200]]]
</code></pre>
<p>这个函数也支持使用 <code>*</code> 作为通配符给相应键名赋值：</p>
<pre><code>$data = [
    'products' =&gt; [
        ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
        ['name' =&gt; 'Desk 2', 'price' =&gt; 150],
    ],
];

data_set($data, 'products.*.price', 200);

/*
    [
        'products' =&gt; [
            ['name' =&gt; 'Desk 1', 'price' =&gt; 200],
            ['name' =&gt; 'Desk 2', 'price' =&gt; 200],
        ],
    ]
*/
</code></pre>
<p>通常情况下，已存在的值将会被覆盖。如果只是希望设置一个目前不存在的值，你可以增加一个 <code>false</code> 作为函数的第四个参数：</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_set($data, 'products.desk.price', 200, false);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]]
</code></pre>
<h4 id="head-collection-method">head() {#collection-method}</h4>
<p><code>head</code> 函数将返回数组中的第一个值：</p>
<pre><code>$array = [100, 200, 300];

$first = head($array);

// 100
</code></pre>
<h4 id="last-collection-method">last() {#collection-method}</h4>
<p><code>last</code> 返回给定数组的最后一个元素：</p>
<pre><code>$array = [100, 200, 300];

$last = last($array);

// 300
</code></pre>
<h3 id="路徑-2">路徑</h3>
<h4 id="app_path-collection-method"><code>app_path()</code> {#collection-method}</h4>
<p><code>app_path</code> 函数返回 <code>app</code> 目录的完整路径。 你也可以用 <code>app_path</code> 函数去生成应用程序目录下一个文件的完整路径：</p>
<pre><code>$path = app_path();

$path = app_path('Http/Controllers/Controller.php');
</code></pre>
<h4 id="base_path-collection-method"><code>base_path()</code> {#collection-method}</h4>
<p><code>base_path</code> 函数返回项目根目录的完整路径。 你也可以用 <code>base_path</code> 函数生成项目根目录下一个文件的完整路径：</p>
<pre><code>$path = base_path();

$path = base_path('vendor/bin');
</code></pre>
<h4 id="config_path-collection-method"><code>config_path()</code> {#collection-method}</h4>
<p><code>config_path</code> 函数返回 <code>config</code> 目录的完整路径。你也可以用 <code>config_path</code> 函数去生成应用程序配置目录下一个指定文件的完整路径：</p>
<pre><code>$path = config_path();

$path = config_path('app.php');
</code></pre>
<h4 id="database_path-collection-method"><code>database_path()</code> {#collection-method}</h4>
<p><code>database_path</code> 函数返回 <code>database</code> 目录的完整路径。 你也可以用 <code>database_path</code> 函数去生成 <code>database</code>目录下一个指定文件的完整路径：</p>
<pre><code>$path = database_path();

$path = database_path('factories/UserFactory.php');
</code></pre>
<h4 id="mix-collection-method"><code>mix()</code> {#collection-method}</h4>
<p><code>mix</code> 返回 <a href="https://learnku.com/docs/laravel/7.x/mix">版本化 MIX 文件</a> 的路径:</p>
<pre><code>$path = mix('css/app.css');
</code></pre>
<h4 id="public_path-collection-method"><code>public_path()</code> {#collection-method}</h4>
<p><code>public_path</code> 函数返回 <code>public</code> 目录的完整路径。 你也可以用 <code>public_path</code> 函数去生成 <code>public</code> 目录下一个指定文件的完整路径：</p>
<pre><code>$path = public_path();

$path = public_path('css/app.css');
</code></pre>
<h4 id="resource_path-collection-method"><code>resource_path()</code> {#collection-method}</h4>
<p><code>resource_path</code> 函数返回 <code>resources</code> 目录的完整路径。你也可以用 <code>resource_path</code> 函数去生成资源文件目录下的一个指定文件的完整路径：</p>
<pre><code>$path = resource_path();

$path = resource_path('sass/app.scss');
</code></pre>
<h4 id="storage_path"><code>storage_path()</code></h4>
<p><code>storage_path</code> 函数返回指向 “storage” 目录的绝对路径。还可以使用 <code>storage_path</code> 函数生成 <code>storage</code> 目录下给定文件的完整路径：</p>
<pre><code>$path = storage_path();

$path = storage_path('app/file.txt');
</code></pre>
<h3 id="字符串函数">字符串函数</h3>
<h4 id="__"><code>__()</code></h4>
<p><code>__</code>函数可使用 本地化文件 翻译指定的字符串或者键值：</p>
<pre><code>echo __('Welcome to our application');

echo __('messages.welcome');
</code></pre>
<p>如果指定的转换字符串或键不存在，<code>__</code> 函数将返回原来的值。即：如果 <code>messages.welcome</code> 键值不存在，则返回 <code>messages.welcome</code>。</p>
<h4 id="e"><code>e()</code></h4>
<p><code>e</code> 函数在指定字符串上运行 htmlentities 方法（double_encode 参数为 false）：</p>
<pre><code>echo e('&lt;html&gt;foo&lt;/html&gt;');

// &amp;lt;html&amp;gt;foo&amp;lt;/html&amp;gt;
</code></pre>
<h4 id="preg_replace_array"><code>preg_replace_array()</code></h4>
<p><code>preg_replace_array</code> 函数使用正则规则用给定数组替换字符串中的内容：</p>
<pre><code>$string = 'The event will take place between :start and :end';

$replaced = preg_replace_array('/:[a-z_]+/', ['8:30', '9:00'], $string);

// The event will take place between 8:30 and 9:00
</code></pre>
<h4 id="strafter"><code>Str::after()</code></h4>
<p><code>Str::after</code> 方法返回字符串中给定值之后的所有内容。如果字符串中不存在该值，则将返回整个字符串：</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::after('This is my name', 'This is');

// ' my name'
</code></pre>
<h4 id="strafterlast"><code>Str::afterLast()</code></h4>
<p><code>Str::afterLast</code> 方法返回字符串中给定值最后一次出现后的所有内容。如果字符串中不存在该值，则将返回整个字符串：</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::afterLast('App\Http\Controllers\Controller', '\\');

// 'Controller'
</code></pre>
<h4 id="strbefore-collection-method"><code>Str::before()</code> {#collection-method}</h4>
<p><code>Str::before</code> 方法返回字符串中给定值之前的所有内容：use Illuminate\Support\Str;</p>
<pre><code>$slice = Str::before('This is my name', 'my name');

// 'This is '
</code></pre>
<h4 id="strbeforelast"><code>Str::beforeLast()</code></h4>
<p><code>Str::beforeLast</code> 方法返回字符串中给定值最后出现之前的所有内容：</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::beforeLast('This is my name', 'is');

// 'This '
</code></pre>
<h4 id="strcamel"><code>Str::camel()</code></h4>
<p><code>Str::camel</code> 方法将给定字符串转换为 <code>camelCase</code>（驼峰式）：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::camel('foo_bar');

// fooBar
</code></pre>
<h4 id="strcontains-collection-method"><code>Str::contains()</code> {#collection-method}</h4>
<p><code>Str::contains</code> 方法判断给定的字符串是否包含给定的值（区分大小写）：</p>
<pre><code>use Illuminate\Support\Str;

$contains = Str::contains('This is my name', 'my');

// true
</code></pre>
<p>你也可以传递一个数组形式的值来判断给定的字符串中是否包含数组中的任意一个值：</p>
<pre><code>use Illuminate\Support\Str;

$contains = Str::contains('This is my name', ['my', 'foo']);

// true
</code></pre>
<h4 id="strcontainsall-collection-method"><code>Str::containsAll()</code> {#collection-method}</h4>
<p><code>Str::containsAll</code> 方法判断给定的字符串中是否包含给定的数组中所有的值：</p>
<pre><code>use Illuminate\Support\Str;

$containsAll = Str::containsAll('This is my name', ['my', 'name']);

// true
</code></pre>
<h4 id="strendswith-collection-method"><code>Str::endsWith()</code> {#collection-method}</h4>
<p><code>Str::endsWith</code> 方法判断给定的字符串是否以给定的值结尾：</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::endsWith('This is my name', 'name');

// true
</code></pre>
<p>你也可以传递一个数组形式的值来判断给定的字符串是否以数组中的任意一个值结尾：</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::endsWith('This is my name', ['name', 'foo']);

// true

$result = Str::endsWith('This is my name', ['this', 'foo']);

// false
</code></pre>
<h4 id="strfinish-collection-method"><code>Str::finish()</code> {#collection-method}</h4>
<p><code>Str::finish</code> 方法将给定的字符串以给定的值结尾返回（如果该字符串尚未以该值结尾）：</p>
<pre><code>use Illuminate\Support\Str;

$adjusted = Str::finish('this/string', '/');

// this/string/

$adjusted = Str::finish('this/string/', '/');

// this/string/
</code></pre>
<h4 id="stris-collection-method"><code>Str::is()</code> {#collection-method}</h4>
<p><code>Str::is</code> 方法判断给定的字符串是否匹配给定的模式，星号 <code>*</code> 可以用来表示通配符：</p>
<pre><code>use Illuminate\Support\Str;

$matches = Str::is('foo*', 'foobar');

// true

$matches = Str::is('baz*', 'foobar');

// false
</code></pre>
<h4 id="strucfirst-collection-method"><code>Str::ucfirst()</code> {#collection-method}</h4>
<p><code>Str::ucfirst</code> 方法将给定的字符串首字母大写并返回：</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::ucfirst('foo bar');

// Foo bar
</code></pre>
<h4 id="strisuuid-collection-method"><code>Str::isUuid()</code> {#collection-method}</h4>
<p><code>Str::isUuid</code> 方法用来确定给定的字符串是否为有效的 UUID：</p>
<pre><code>use Illuminate\Support\Str;

$isUuid = Str::isUuid('a0a2a2d2-0b87-4a18-83f2-2529882be2de');

// true

$isUuid = Str::isUuid('laravel');

// false
</code></pre>
<h4 id="strkebab-collection-method"><code>Str::kebab()</code> {#collection-method}</h4>
<p><code>Str::kebab</code> 方法将给定的「驼峰式」字符串转化为 kebab-case「短横式」字符串</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::kebab('fooBar');

// foo-bar
</code></pre>
<h4 id="strlimit-collection-method"><code>Str::limit()</code> {#collection-method}</h4>
<p><code>Str::limit</code> 方法按给定的长度截断给定的字符串：</p>
<pre><code>use Illuminate\Support\Str;

$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20);

// The quick brown fox...
</code></pre>
<p>你也可以传递第三个参数来改变将被追加到最后的字符串：</p>
<pre><code>use Illuminate\Support\Str;

$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20, ' (...)');

// The quick brown fox (...)
</code></pre>
<h4 id="strordereduuid-collection-method"><code>Str::orderedUuid()</code> {#collection-method}</h4>
<p><code>Str::orderedUuid</code> 方法高效生成一个可存储在索引数据库列中的「第一时间」 UUID：</p>
<pre><code>use Illuminate\Support\Str;

return (string) Str::orderedUuid();
</code></pre>
<h4 id="strplural-collection-method"><code>Str::plural()</code> {#collection-method}</h4>
<p><code>Str::plural</code> 函数将字符串转换为复数形式。该函数目前仅支持英文</p>
<pre><code>use Illuminate\Support\Str;

$plural = Str::plural('car');

// cars

$plural = Str::plural('child');

// children
</code></pre>
<p>你可以提供一个整数作为函数的第二个参数来检索字符串的单数或复数形式：</p>
<pre><code>use Illuminate\Support\Str;

$plural = Str::plural('child', 2);

// children

$plural = Str::plural('child', 1);

// child
</code></pre>
<h4 id="strrandom-collection-method"><code>Str::random()</code> {#collection-method}</h4>
<p><code>Str::random</code> 函数生成一个指定长度的随机字符串。这个函数用 PHP 的 <code>random_bytes</code> 函数：</p>
<pre><code>use Illuminate\Support\Str;

$random = Str::random(40);
</code></pre>
<h4 id="strreplacearray-collection-method"><code>Str::replaceArray()</code> {#collection-method}</h4>
<p><code>Str::replaceArray</code> 函数使用数组顺序替换字符串中的给定值：</p>
<pre><code>use Illuminate\Support\Str;

$string = 'The event will take place between ? and ?';

$replaced = Str::replaceArray('?', ['8:30', '9:00'], $string);

// 活动将在 8:30 至 9:00 之间进行
</code></pre>
<h4 id="strreplacefirst-collection-method"><code>Str::replaceFirst()</code> {#collection-method}</h4>
<p><code>Str::replaceFirst</code> 函数替换字符串中给定值的第一个匹配项：</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::replaceFirst('the', 'a', 'the quick brown fox jumps over the lazy dog');

// a quick brown fox jumps over the lazy dog
</code></pre>
<h4 id="strreplacelast-collection-method"><code>Str::replaceLast()</code> {#collection-method}</h4>
<p><code>Str::replaceLast</code> 函数替换字符串中最后一次出现的给定值：</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::replaceLast('the', 'a', 'the quick brown fox jumps over the lazy dog');

// the quick brown fox jumps over a lazy dog
</code></pre>
<h4 id="strsingular-collection-method"><code>Str::singular()</code> {#collection-method}</h4>
<p><code>Str::singular</code> 函数将字符串转换为单数形式。该函数目前仅支持英文：</p>
<pre><code>use Illuminate\Support\Str;

$singular = Str::singular('cars');

// car

$singular = Str::singular('children');

// child
</code></pre>
<h4 id="strslug-collection-method"><code>Str::slug()</code> {#collection-method}</h4>
<p><code>Str::slug</code> 函数将给定的字符串生成一个 URL 友好的 「slug」 ：</p>
<pre><code>use Illuminate\Support\Str;

$slug = Str::slug('Laravel 5 Framework', '-');

// laravel-5-framework
</code></pre>
<h4 id="strsnake-collection-method"><code>Str::snake()</code> {#collection-method}</h4>
<p><code>Str::snake</code> 函数将给定的字符串转换为 <code>snake_case</code>「蛇式」：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::snake('fooBar');

// foo_bar
</code></pre>
<h4 id="strstart-collection-method"><code>Str::start()</code> {#collection-method}</h4>
<p><code>Str::start</code> 函数将给定值添加到给定字符串的开始位置（如果字符串尚未以给定值开始）：</p>
<pre><code>use Illuminate\Support\Str;

$adjusted = Str::start('this/string', '/');

// /this/string

$adjusted = Str::start('/this/string', '/');

// /this/string
</code></pre>
<h4 id="strstartswith-collection-method"><code>Str::startsWith()</code> {#collection-method}</h4>
<p><code>Str::startsWith</code> 函数判断给定的字符串的开头是否是指定值：</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::startsWith('This is my name', 'This');

// true
</code></pre>
<h4 id="strstudly-collection-method"><code>Str::studly()</code> {#collection-method}</h4>
<p><code>Str::studly</code> 函数将给定的字符串转换为 「变种驼峰命名」：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::studly('foo_bar');

// FooBar
</code></pre>
<h4 id="strtitle-collection-method"><code>Str::title()</code> {#collection-method}</h4>
<p><code>Str::title</code> 函数将给定的字符串转换为「首字母大写」：</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::title('a nice title uses the correct case');

// A Nice Title Uses The Correct Case
</code></pre>
<h4 id="struuid-collection-method"><code>Str::uuid()</code> {#collection-method}</h4>
<p><code>Str::uuid</code> 方法生成一个 UUID（版本 4）：</p>
<pre><code>use Illuminate\Support\Str;

return (string) Str::uuid();
</code></pre>
<h4 id="strwords-collection-method"><code>Str::words()</code> {#collection-method}</h4>
<p><code>Str::words</code> 函数限制字符串中的单词数：</p>
<pre><code>use Illuminate\Support\Str;

return Str::words('Perfectly balanced, as all things should be.', 3, ' &gt;&gt;&gt;');

// Perfectly balanced, as &gt;&gt;&gt;
</code></pre>
<h4 id="trans-collection-method"><code>trans()</code> {#collection-method}</h4>
<p><code>trans</code> 函数使用你的 本地文件（如：/xiewxin.github.io/docs/laravel/resources/lang/en.json） 转换给定的翻译密钥</p>
<pre><code>echo trans('messages.welcome');
</code></pre>
<p>如果指定的翻译键不存在，则 <code>trans</code> 方法会简单地返回给定的键。所以，就上面的例子而言，如果翻译键不存在， <code>trans</code> 方法会返回 <code>messages.welcome</code></p>
<h4 id="trans_choice-collection-method"><code>trans_choice()</code> {#collection-method}</h4>
<p><code>trans_choice</code> 函数根据词形变化来翻译给定的翻译键：</p>
<p>如果指定的翻译键不存在， <code>trans_choice</code> 方法会简单地返回给定的键。所以，按照上面的例子，如果翻译键不存在，<code>trans_choice</code> 方法会返回 <code>messages.notifications</code>。</p>
]]></content>
    </entry>
</feed>